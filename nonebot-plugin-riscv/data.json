[{"name": "add", "content": "add rd, rs1, rs2\nx[rd] = x[rs1] + x[rs2]\n加  (Add). R-type, RV32I and RV64I.\n把寄存器 x[rs2]加到寄存器 x[rs1]上，结果写入 x[rd]。忽略算术溢出。\n压缩形式：c.add rd, rs2; c.mv rd, rs2\n0000000 rs2 rs1 000 Rd 0110011\n", "relevant": ["addi", "addw", "and"]}, {"name": "addi", "content": "addi rd, rs1, immediate\nx[rd] = x[rs1] + sext(immediate)\n加立即数(Add Immediate). I-type, RV32I and RV64I.\n把符号位扩展的立即数加到寄存器 x[rs1]上，结果写入 x[rd]。忽略算术溢出。\n压缩形式：c.li rd, imm; c.addi rd, imm; c.addi16sp imm; c.addi4spn rd, imm\nimmediate[11:0] rs1 000 rd 0010011\n", "relevant": ["add", "addiw", "addw", "andi"]}, {"name": "addiw", "content": "addiw rd, rs1, immediate\nx[rd] = sext((x[rs1] + sext(immediate))[31:0])\n加立即数字(Add Word Immediate). I-type, RV64I.\n把符号位扩展的立即数加到 x[rs1]，将结果截断为 32 位，把符号位扩展的结果写入 x[rd]。\n忽略算术溢出。\n压缩形式：c.addiw rd, imm\nimmediate[11:0] rs1 000 rd 0011011\n", "relevant": ["addi", "addw"]}, {"name": "addw", "content": "addw rd, rs1, rs2\nx[rd] = sext((x[rs1] + x[rs2])[31:0])\n加字(Add Word). R-type, RV64I.\n把寄存器 x[rs2]加到寄存器 x[rs1]上，将结果截断为 32 位，把符号位扩展的结果写入 x[rd]。\n忽略算术溢出。\n压缩形式：c.addw rd, rs2\n0000000 rs2 rs1 000 rd 0111011\n", "relevant": ["add", "addi", "addiw"]}, {"name": "amoadd.d", "content": "amoadd.d rd, rs2, (rs1)\nx[rd] = AMO64(M[x[rs1]] + x[rs2])\n原子加双字(Atomic Memory Operation: Add Doubleword). R-type, RV64A.\n进行如下的原子操作：将内存中地址为 x[rs1]中的双字记为 t，把这个双字变为 t+x[rs2]，把 x[rd] 设为 t。\n00000 aq rl rs2 rs1 011 rd 0101111\n", "relevant": ["amoadd.w", "amoand.d"]}, {"name": "amoadd.w", "content": "amoadd.w rd, rs2, (rs1)\nx[rd] = AMO32(M[x[rs1]] + x[rs2])\n原子加字(Atomic Memory Operation: Add Word). R-type, RV32A and RV64A.\n进行如下的原子操作：将内存中地址为 x[rs1]中的字记为 t，把这个字变为 t+x[rs2]，把 x[rd] 设为符号位扩展的 t。\n00000 aq rl rs2 rs1 010 rd 0101111\n", "relevant": ["amoadd.d", "amoand.w"]}, {"name": "amoand.d", "content": "amoand.d rd, rs2, (rs1)\nx[rd] = AMO64(M[x[rs1]] & x[rs2])\n原子双字与  (Atomic Memory Operation: AND Doubleword). R-type, RV64A.\n进行如下的原子操作：将内存中地址为 x[rs1]中的双字记为 t，把这个双字变为 t 和 x[rs2]位与的结果，把 x[rd]设为 t。\n01100 aq rl rs2 rs1 011 rd 0101111\n", "relevant": ["amoadd.d", "amoand.w"]}, {"name": "amoand.w", "content": "amoand.w rd, rs2, (rs1)\nx[rd] = AMO32(M[x[rs1]] & x[rs2])\n原子字与  (Atomic Memory Operation: AND Word). R-type, RV32A and RV64A.\n进行如下的原子操作：将内存中地址为 x[rs1]中的字记为 t，把这个字变为 t 和 x[rs2]位与的结果，把 x[rd]设为符号位扩展的 t。\n01100 aq rl rs2 rs1 010 rd 0101111\n", "relevant": ["amoadd.w", "amoand.d"]}, {"name": "amomax.d", "content": "amomax.d rd, rs2, (rs1)\nx[rd] = AMO64(M[x[rs1]] MAX x[rs2])\n原子最大双字(Atomic Memory Operation: Maximum Doubleword). R-type, RV64A.\n进行如下的原子操作：将内存中地址为 x[rs1]中的双字记为 t，把这个双字变为 t 和 x[rs2]中较大的一个（用二进制补码比较），把 x[rd]设为 t。\n10100 aq rl rs2 rs1 011 rd 0101111\n", "relevant": ["amomax.w", "amomaxu.d"]}, {"name": "amomax.w", "content": "amomax.w rd, rs2, (rs1)\nx[rd] = AMO32(M[x[rs1]] MAX x[rs2])\n原子最大字(Atomic Memory Operation: Maximum Word). R-type, RV32A and RV64A.\n进行如下的原子操作：将内存中地址为 x[rs1]中的字记为 t，把这个字变为 t 和 x[rs2]中较大的一个（用二进制补码比较），把 x[rd]设为符号位扩展的 t。\n10100 aq rl rs2 rs1 010 rd 0101111\n", "relevant": ["amomax.d", "amomaxu.w"]}, {"name": "amomaxu.d", "content": "amomaxu.d rd, rs2, (rs1)\nx[rd] = AMO64(M[x[rs1]] MAXU x[rs2])\n原子无符号最大双字(Atomic Memory Operation: Maximum Doubleword, Unsigned). R-type,\nRV64A.\n进行如下的原子操作：将内存中地址为 x[rs1]中的双字记为 t，把这个双字变为 t 和 x[rs2]中较大的一个（用无符号比较），把 x[rd]设为 t。\n11100 aq rl rs2 rs1 011 rd 0101111\n", "relevant": ["amomax.d", "amomaxu.w"]}, {"name": "amomaxu.w", "content": "amomaxu.w rd, rs2, (rs1)\nx[rd] = AMO32(M[x[rs1]] MAXU x[rs2])\n原子无符号最大字(Atomic Memory Operation: Maximum Word, Unsigned). R-type, RV32A and\nRV64A.\n进行如下的原子操作：将内存中地址为 x[rs1]中的字记为 t，把这个字变为 t 和 x[rs2]中较大的一个（用无符号比较），把 x[rd]设为符号位扩展的 t。\n11100 aq rl rs2 rs1 010 rd 0101111\n", "relevant": ["amomax.w", "amomaxu.d"]}, {"name": "amomin.d", "content": "amomin.d rd, rs2, (rs1)\nx[rd] = AMO64(M[x[rs1]] MIN x[rs2])\n原子最小双字(Atomic Memory Operation: Minimum Doubleword). R-type, RV64A.\n进行如下的原子操作：将内存中地址为 x[rs1]中的双字记为 t，把这个双字变为 t 和 x[rs2]中较小的一个（用二进制补码比较），把 x[rd]设为 t。\n10000 aq rl rs2 rs1 011 rd 0101111\n", "relevant": ["amomin.w", "amominu.d"]}, {"name": "amomin.w", "content": "amomin.w rd, rs2, (rs1)\nx[rd] = AMO32(M[x[rs1]] MIN x[rs2])\n原子最小字(Atomic Memory Operation: Minimum Word). R-type, RV32A and RV64A.\n进行如下的原子操作：将内存中地址为 x[rs1]中的字记为 t，把这个字变为 t 和 x[rs2]中较小的一个（用二进制补码比较），把 x[rd]设为符号位扩展的 t。\n10000 aq rl rs2 rs1 010 rd 0101111\n", "relevant": ["amomin.d", "amominu.w"]}, {"name": "amominu.d", "content": "amominu.d rd, rs2,(rs1)\nx[rd] = AMO64(M[x[rs1]] MINU x[rs2])\n原子无符号最小双字(Atomic Memory Operation: Minimum Doubleword, Unsigned). R-type,\nRV64A.\n进行如下的原子操作：将内存中地址为 x[rs1]中的双字记为 t，把这个双字变为 t 和 x[rs2]中较小的一个（用无符号比较），把 x[rd]设为 t。\n11000 aq rl rs2 rs1 011 rd 0101111\n", "relevant": ["amomin.d", "amominu.w"]}, {"name": "amominu.w", "content": "amominu.w rd, rs2, (rs1)\nx[rd] = AMO32(M[x[rs1]] MINU x[rs2])\n原子无符号最大字(Atomic Memory Operation: Minimum Word, Unsigned). R-type, RV32A and\nRV64A.\n进行如下的原子操作：将内存中地址为 x[rs1]中的字记为 t，把这个字变为 t 和 x[rs2]中较小的一个（用无符号比较），把 x[rd]设为符号位扩展的 t。\n11000 aq rl rs2 rs1 010 rd 0101111\n", "relevant": ["amomin.w", "amominu.d"]}, {"name": "amoor.d", "content": "amoor.d rd, rs2, (rs1)\nx[rd] = AMO64(M[x[rs1]] | x[rs2])\n原子双字或  (Atomic Memory Operation: OR Doubleword). R-type, RV64A.\n进行如下的原子操作：将内存中地址为 x[rs1]中的双字记为 t，把这个双字变为 t 和 x[rs2]位或的结果，把 x[rd]设为 t。\n01000 aq rl rs2 rs1 011 rd 0101111\n", "relevant": ["amoor.w", "amoor.w", "amoxor.d"]}, {"name": "amoor.w", "content": "amoor.w rd, rs2, (rs1)\nx[rd] = AMO32(M[x[rs1]] | x[rs2])\n原子字或  (Atomic Memory Operation: OR Word). R-type, RV32A and RV64A.\n进行如下的原子操作：将内存中地址为 x[rs1]中的字记为 t，把这个字变为 t 和 x[rs2]位或的结果，把 x[rd]设为符号位扩展的 t。\n01000 aq rl rs2 rs1 010 rd 0101111\n", "relevant": ["amoor.d", "amoxor.w"]}, {"name": "amoswap.d", "content": "amoswap.d rd, rs2, (rs1)\nx[rd] = AMO64(M[x[rs1]] SWAP x[rs2])\n原子双字交换  (Atomic Memory Operation: Swap Doubleword). R-type, RV64A.\n进行如下的原子操作：将内存中地址为 x[rs1]中的双字记为 t，把这个双字变为 x[rs2]的值，\n把 x[rd]设为 t。\n00001 aq rl rs2 rs1 011 rd 0101111\n", "relevant": []}, {"name": "amoor.w", "content": "amoor.w rd, rs2, (rs1)\nx[rd] = AMO32(M[x[rs1]] SWAP x[rs2])\n原子字交换  (Atomic Memory Operation: Swap Word). R-type, RV32A and RV64A.\n进行如下的原子操作：将内存中地址为 x[rs1]中的字记为 t，把这个字变为 x[rs2]的值，把x[rd]设为符号位扩展的 t。\n00001 aq rl rs2 rs1 010 rd 0101111\n", "relevant": ["amoor.d", "amoxor.w"]}, {"name": "amoxor.d", "content": "amoxor.d rd, rs2, (rs1)\nx[rd] = AMO64(M[x[rs1]] ^ x[rs2])\n原子双字异或  (Atomic Memory Operation: XOR Doubleword). R-type, RV64A.\n进行如下的原子操作：将内存中地址为 x[rs1]中的双字记为 t，把这个双字变为 t 和 x[rs2]按位异或的结果，把 x[rd]设为 t。\n00100 aq rl rs2 rs1 011 rd 0101111\n", "relevant": ["amoor.d", "amoxor.w"]}, {"name": "amoxor.w", "content": "amoxor.w rd, rs2, (rs1)\nx[rd] = AMO32(M[x[rs1]] ^ x[rs2])\n原子字异或  (Atomic Memory Operation: XOR Word). R-type, RV32A and RV64A.\n进行如下的原子操作：将内存中地址为 x[rs1]中的字记为 t，把这个字变为 t 和 x[rs2]按位异或的结果，把 x[rd]设为符号位扩展的 t。\n00100 aq rl rs2 rs1 010 rd 0101111\n", "relevant": ["amoor.w", "amoor.w", "amoxor.d"]}, {"name": "and", "content": "and  rd, rs1, rs2\nx[rd] = x[rs1] & x[rs2]\n与  (And). R-type, RV32I and RV64I.\n将寄存器 x[rs1]和寄存器 x[rs2]位与的结果写入 x[rd]。\n压缩形式：c.and rd, rs2\n0000000 rs2 rs1 111 rd 0110011\n", "relevant": ["add", "andi"]}, {"name": "andi", "content": "andi rd, rs1, immediate\nx[rd] = x[rs1] & sext(immediate)\n与立即数 (And Immediate). I-type, RV32I and RV64I.\n把符号位扩展的立即数和寄存器 x[rs1]上的值进行位与，结果写入 x[rd]。\n压缩形式：c.andi rd, imm\nimmediate[11:0] rs1 111 rd 0010011\n", "relevant": ["addi", "and"]}, {"name": "auipc", "content": "auipc rd, immediate\nx[rd] = pc + sext(immediate[31:12] << 12)\nPC 加立即数 (Add Upper Immediate to PC). U-type, RV32I and RV64I.\n把符号位扩展的 20 位（左移 12 位）立即数加到 pc 上，结果写入 x[rd]。\nimmediate[31:12] rd 0010111\n", "relevant": []}, {"name": "beq", "content": "beq rs1, rs2, offset\nif (rs1 == rs2) pc += sext(offset)\n相等时分支  (Branch if Equal). B-type, RV32I and RV64I.\n若寄存器 x[rs1]和寄存器 x[rs2]的值相等，把 pc 的值设为当前值加上符号位扩展的偏移 offset。\n压缩形式：c.beqz rs1, offset\noffset[12|10:5] rs2 rs1 000 offset[4:1|11] 1100011\n", "relevant": ["beqz"]}, {"name": "beqz", "content": "beqz rs1, offset\nif (rs1 == 0) pc += sext(offset)\n等于零时分支  (Branch if Equal to Zero).  伪指令(Pesudoinstruction), RV32I and RV64I.\n可视为 beq rs1, x0, offset.\n", "relevant": ["beq", "seqz"]}, {"name": "bge", "content": "bge rs1, rs2, offset\nif (rs1 ≥s rs2) pc += sext(offset)\n大于等于时分支  (Branch if Greater Than or Equal). B-type, RV32I and RV64I.\n若寄存器 x[rs1]的值大于等于寄存器 x[rs2]的值（均视为二进制补码），把 pc 的值设为当前值加上符号位扩展的偏移 offset。\noffset[12|10:5] rs2 rs1 101 offset[4:1|11] 1100011\n", "relevant": ["bgeu", "bgez", "bgt", "ble", "bne"]}, {"name": "bgeu", "content": "bgeu rs1, rs2, offset\nif (rs1 ≥u rs2) pc += sext(offset)\n无符号大于等于时分支  (Branch if Greater Than or Equal, Unsigned). B-type, RV32I and RV64I.\n若寄存器 x[rs1]的值大于等于寄存器 x[rs2]的值（均视为无符号数），把 pc 的值设为当前值加上符号位扩展的偏移 offset。\noffset[12|10:5] rs2 rs1 111 offset[4:1|11] 1100011\n", "relevant": ["bge", "bgez", "bgtu", "bleu"]}, {"name": "bgez", "content": "bgez rs1, offset\nif (rs1 ≥s 0) pc += sext(offset)\n大于等于零时分支  (Branch if Greater Than or Equal to Zero).  伪指令(Pesudoinstruction),\nRV32I and RV64I.\n可视为 bge rs1, x0, offset.\n", "relevant": ["bge", "bgeu", "bgtz", "blez", "bnez"]}, {"name": "bgt", "content": "bgt rs1, rs2, offset\nif (rs1 >s rs2) pc += sext(offset)\n大于时分支  (Branch if Greater Than).  伪指令(Pesudoinstruction), RV32I and RV64I.\n可视为 blt rs2, rs1, offset.\n", "relevant": ["bge", "bgtu", "bgtz", "blt"]}, {"name": "bgtu", "content": "bgtu rs1, rs2, offset\nif (rs1 >u rs2) pc += sext(offset)\n无符号大于时分支  (Branch if Greater Than, Unsigned).  伪指令(Pesudoinstruction), RV32I and\nRV64I.\n可视为 bltu rs2, rs1, offset.\n", "relevant": ["bgeu", "bgt", "bgtz", "bltu"]}, {"name": "bgtz", "content": "bgtz rs1, offset\nif (rs2 >s 0) pc += sext(offset)\n大于零时分支  (Branch if Greater Than Zero).  伪指令(Pesudoinstruction), RV32I and RV64I.\n可视为 blt x0, rs2, offset.\n", "relevant": ["bgez", "bgt", "bgtu", "bltz", "sgtz"]}, {"name": "ble", "content": "ble rs1, rs2, offset\nif (rs1 ≤s rs2) pc += sext(offset)\n小于等于时分支  (Branch if Less Than or Equal).  伪指令(Pesudoinstruction), RV32I and RV64I.\n可视为 bge rs2, rs1, offset.\n", "relevant": ["bge", "bleu", "blez", "blt", "bne"]}, {"name": "bleu", "content": "bleu rs1, rs2, offset\nif (rs1 ≤u rs2) pc += sext(offset)\n小于等于时分支  (Branch if Less Than or Equal, Unsigned).  伪指令(Pesudoinstruction), RV32I\nand RV64I.\n可视为 bgeu rs2, rs1, offset.\n", "relevant": ["bgeu", "ble", "blez", "bltu"]}, {"name": "blez", "content": "blez rs2, offset\nif (rs2 ≤s 0) pc += sext(offset)\n小于等于零时分支  (Branch if Less Than or Equal to Zero).  伪指令(Pesudoinstruction), RV32I\nand RV64I.\n可视为 bge x0, rs2, offset.\n", "relevant": ["bgez", "ble", "bleu", "bltz", "bnez"]}, {"name": "blt", "content": "blt rs1, rs2, offset\nif (rs1 <s rs2) pc += sext(offset)\n小于时分支  (Branch if Less Than). B-type, RV32I and RV64I.\n若寄存器 x[rs1]的值小于寄存器 x[rs2]的值（均视为二进制补码），把 pc 的值设为当前值加上符号位扩展的偏移 offset。\noffset[12|10:5] rs2 rs1 100 offset[4:1|11] 1100011\n", "relevant": ["bgt", "ble", "bltz", "bltu", "slt"]}, {"name": "bltz", "content": "bltz rs2, offset\nif (rs1 <s 0) pc += sext(offset)\n小于零时分支  (Branch if Less Than Zero).  伪指令(Pesudoinstruction), RV32I and RV64I.\n可视为 blt rs1, x0, offset.\n", "relevant": ["bgtz", "blez", "blt", "bltu", "sltz"]}, {"name": "bltu", "content": "bltu rs1, rs2, offset\nif (rs1 <u rs2) pc += sext(offset)\n无符号小于时分支  (Branch if Less Than, Unsigned). B-type, RV32I and RV64I.\n若寄存器 x[rs1]的值小于寄存器 x[rs2]的值（均视为无符号数），把 pc 的值设为当前值加上符号位扩展的偏移 offset。\noffset[12|10:5] rs2 rs1 110 offset[4:1|11] 1100011\n", "relevant": ["bgtu", "bleu", "blt", "bltz", "sltu"]}, {"name": "bne", "content": "bne rs1, rs2, offset\nif (rs1 ≠ rs2) pc += sext(offset)\n不相等时分支  (Branch if Not Equal). B-type, RV32I and RV64I.\n若寄存器 x[rs1]和寄存器 x[rs2]的值不相等，把 pc 的值设为当前值加上符号位扩展的偏移offset。\n压缩形式：c.bnez rs1, offset\noffset[12|10:5] rs2 rs1 001 offset[4:1|11] 1100011\n", "relevant": ["bge", "ble", "bnez"]}, {"name": "bnez", "content": "bnez rs1, offset\nif (rs1 ≠ 0) pc += sext(offset)\n不等于零时分支  (Branch if Not Equal to Zero).  伪指令(Pesudoinstruction), RV32I and RV64I.\n可视为 bne rs1, x0, offset.\n", "relevant": ["bgez", "blez", "bne", "snez"]}, {"name": "call", "content": "call rd, symbol\nx[rd] = pc+8; pc = &symbol 调用  (Call).  伪指令(Pesudoinstruction), RV32I and RV64I.\n把下一条指令的地址（pc+8）写入 x[rd]，然后把 pc 设为 symbol。等同于 auipc rd, offestHi,\n再加上一条 jalr rd, offsetLo(rd). 若省略了 rd，默认为 x1.\n", "relevant": ["ecall"]}, {"name": "csrr", "content": "csrr rd, csr\nx[rd] = CSRs[csr] 读控制状态寄存器  (Control and Status Register Read).  伪指令(Pesudoinstruction), RV32I and\nRV64I.\n把控制状态寄存器 csr 的值写入 x[rd]，等同于 csrrs rd, csr, x0.\n", "relevant": ["csrc", "csrrc", "csrrs", "csrrw", "csrc", "csrw"]}, {"name": "csrc", "content": "csrc csr, rs1\nCSRs[csr] &= ~x[rs1] 清除控制状态寄存器  (Control and Status Register Clear).  伪指令(Pesudoinstruction), RV32I\nand RV64I.\n对于 x[rs1]中每一个为 1 的位，把控制状态寄存器 csr 的的对应位清零，等同于 csrrc x0, csr,\nrs1.\n", "relevant": ["csrr", "csrci", "csrrc", "csrci", "csrw"]}, {"name": "csrci", "content": "csrci csr, zimm[4:0]\nCSRs[csr] &= ~zimm\n立即数清除控制状态寄存器  (Control  and  Status  Register  Clear  Immediate).  伪指令(Pesudoinstruction), RV32I and RV64I.\n对于五位的零扩展的立即数中每一个为 1 的位，把控制状态寄存器 csr 的的对应位清零，等同于 csrrci x0, csr, zimm.\n", "relevant": ["csrc", "csrrci", "csrrci", "csrc", "csrwi"]}, {"name": "csrrc", "content": "csrrc rd, csr, rs1\nt = CSRs[csr]; CSRs[csr] = t &~x[rs1]; x[rd] = t\n读后清除控制状态寄存器  (Control and Status Register Read and Clear). I-type, RV32I and\nRV64I.\n记控制状态寄存器 csr 中的值为 t。把 t 和寄存器 x[rs1]按位与的结果写入 csr，再把 t 写入x[rd]。\ncsr rs1 011 rd 1110011\n", "relevant": ["csrr", "csrc", "csrrci", "csrrs", "csrrci", "csrrw", "csrc"]}, {"name": "csrrci", "content": "csrrci rd, csr, zimm[4:0]\nt = CSRs[csr]; CSRs[csr] = t &~zimm; x[rd] = t\n立即数读后清除控制状态寄存器  (Control and Status Register Read and Clear Immediate). I-\ntype, RV32I and RV64I.\n记控制状态寄存器 csr 中的值为 t。把 t 和五位的零扩展的立即数 zimm 按位与的结果写入csr，再把 t 写入 x[rd]（csr 寄存器的第 5 位及更高位不变）。\ncsr zimm[4:0] 111 rd 1110011\n", "relevant": ["csrci", "csrrc", "csrrwi", "csrci"]}, {"name": "csrrs", "content": "csrrs rd, csr, rs1\nt = CSRs[csr]; CSRs[csr] = t | x[rs1]; x[rd] = t\n读后置位控制状态寄存器  (Control and Status Register Read and Set). I-type, RV32I and RV64I.\n记控制状态寄存器 csr 中的值为 t。把 t 和寄存器 x[rs1]按位或的结果写入 csr，再把 t 写入x[rd]。\ncsr rs1 010 rd 1110011\n", "relevant": ["csrr", "csrrc", "csrrw"]}, {"name": "csrrci", "content": "csrrci rd, csr, zimm[4:0]    t = CSRs[csr]; CSRs[csr] = t | zimm; x[rd] = t\n立即数读后设置控制状态寄存器  (Control and Status Register Read and Set Immediate). I-type,\nRV32I and RV64I.\n记控制状态寄存器 csr 中的值为 t。把 t 和五位的零扩展的立即数 zimm 按位或的结果写入csr，再把 t 写入 x[rd]（csr 寄存器的第 5 位及更高位不变）。\ncsr zimm[4:0] 110 rd 1110011\n", "relevant": ["csrci", "csrrc", "csrrwi", "csrci"]}, {"name": "csrrw", "content": "csrrw rd, csr, zimm[4:0]\nt = CSRs[csr]; CSRs[csr] = x[rs1]; x[rd] = t\n读后写控制状态寄存器  (Control and Status Register Read and Write). I-type, RV32I and RV64I.\n记控制状态寄存器 csr 中的值为 t。把寄存器 x[rs1]的值写入 csr，再把 t 写入 x[rd]。\ncsr rs1 001 rd 1110011\n", "relevant": ["csrr", "csrrc", "csrrs", "csrrwi", "csrw"]}, {"name": "csrrwi", "content": "csrrwi rd, csr, zimm[4:0]\nx[rd] = CSRs[csr]; CSRs[csr] = zimm\n立即数读后写控制状态寄存器  (Control and Status Register Read and Write Immediate). I-type,\nRV32I and RV64I.\n把控制状态寄存器 csr 中的值拷贝到 x[rd]中，再把五位的零扩展的立即数 zimm 的值写入csr。\ncsr zimm[4:0] 101 rd 1110011\n", "relevant": ["csrrci", "csrrci", "csrrw", "csrwi"]}, {"name": "csrc", "content": "csrc csr, rs1\nCSRs[csr] |= x[rs1]\n置位控制状态寄存器  (Control and Status Register Set).  伪指令(Pesudoinstruction), RV32I and\nRV64I.\n对于 x[rs1]中每一个为 1 的位，把控制状态寄存器 csr 的的对应位置位，等同于 csrrs x0, csr,\nrs1.\n", "relevant": ["csrr", "csrci", "csrrc", "csrci", "csrw"]}, {"name": "csrci", "content": "csrci csr, zimm[4:0]\nCSRs[csr] |= zimm 立即数置位控制状态寄存器  (Control  and  Status  Register  Set  Immediate).  伪指令(Pesudoinstruction), RV32I and RV64I.\n对于五位的零扩展的立即数中每一个为 1 的位，把控制状态寄存器 csr 的的对应位清零，等同于 csrrsi x0, csr, zimm.\n", "relevant": ["csrc", "csrrci", "csrrci", "csrc", "csrwi"]}, {"name": "csrw", "content": "csrw csr, rs1\nCSRs[csr] = x[rs1]\n写控制状态寄存器  (Control and Status Register Set).  伪指令(Pesudoinstruction), RV32I and\nRV64I.\n对于 x[rs1]中每一个为 1 的位，把控制状态寄存器 csr 的的对应位置位，等同于 csrrs x0, csr,\nrs1.\n", "relevant": ["csrr", "csrc", "csrrw", "csrc", "csrwi"]}, {"name": "csrwi", "content": "csrwi csr, zimm[4:0]\nCSRs[csr] = zimm\n立即数写控制状态寄存器  (Control  and  Status  Register  Write  Immediate).  伪指令(Pesudoinstruction), RV32I and RV64I.\n把五位的零扩展的立即数的值写入控制状态寄存器 csr 的，等同于 csrrwi x0, csr, zimm.\n", "relevant": ["csrci", "csrrwi", "csrci", "csrw"]}, {"name": "div", "content": "div rd, rs1, rs2\nx[rd] = x[rs1] ÷s x[rs2]\n除法(Divide). R-type, RV32M and RV64M.\n用寄存器 x[rs1]的值除以寄存器 x[rs2]的值，向零舍入，将这些数视为二进制补码，把商写入 x[rd]。\n0000001 rs2 rs1 100 rd 0110011\n", "relevant": ["divu", "divw"]}, {"name": "divu", "content": "divu rd, rs1, rs2\nx[rd] = x[rs1] ÷u x[rs2]\n无符号除法(Divide, Unsigned). R-type, RV32M and RV64M.\n用寄存器 x[rs1]的值除以寄存器 x[rs2]的值，向零舍入，将这些数视为无符号数，把商写入x[rd]。\n0000001 rs2 rs1 101 rd 0110011\n", "relevant": ["div", "divuw", "divw"]}, {"name": "divuw", "content": "divuw rd, rs1, rs2\nx[rd] = sext(x[rs1][31:0] ÷u x[rs2][31:0])\n无符号字除法(Divide Word, Unsigned). R-type, RV64M.\n用寄存器 x[rs1]的低 32 位除以寄存器 x[rs2]的低 32 位，向零舍入，将这些数视为无符号数，\n把经符号位扩展的 32 位商写入 x[rd]。\n0000001 rs2 rs1 101 rd 0111011\n", "relevant": ["divu", "divw"]}, {"name": "divw", "content": "divw rd, rs1, rs2\nx[rd] = sext(x[rs1][31:0] ÷s x[rs2][31:0])\n字除法(Divide Word). R-type, RV64M.\n用寄存器 x[rs1]的低 32 位除以寄存器 x[rs2]的低 32 位，向零舍入，将这些数视为二进制补码，把经符号位扩展的 32 位商写入 x[rd]。\n0000001 rs2 rs1 100 rd 0111011\n", "relevant": ["div", "divu", "divuw"]}, {"name": "Ebreak", "content": "Ebreak\nRaiseException(Breakpoint)\n环境断点 (Environment Breakpoint). I-type, RV32I and RV64I.\n通过抛出断点异常的方式请求调试器。\n000000000001 00000 000 00000 1110011\n", "relevant": []}, {"name": "ecall", "content": "ecall\nRaiseException(EnvironmentCall)\n环境调用 (Environment Call). I-type, RV32I and RV64I.\n通过引发环境调用异常来请求执行环境。\n000000000000 00000 000 00000 1110011\n", "relevant": ["call"]}, {"name": "fabs.d", "content": "fabs.d rd, rs1\nf[rd] = |f[rs1]|\n浮点数绝对值  (Floating-point Absolute Value).  伪指令(Pesudoinstruction), RV32D and RV64D.\n把双精度浮点数 f[rs1]的绝对值写入 f[rd]。\n等同于 fsgnjx.d rd, rs1, rs1.\n", "relevant": ["fabs.s"]}, {"name": "fabs.s", "content": "fabs.s rd, rs1\nf[rd] = |f[rs1]| 浮点数绝对值  (Floating-point Absolute Value).  伪指令(Pesudoinstruction), RV32F and RV64F.\n把单精度浮点数 f[rs1]的绝对值写入 f[rd]。\n等同于 fsgnjx.s rd, rs1, rs1.\n", "relevant": ["fabs.d"]}, {"name": "fadd.d", "content": "fadd.d rd, rs1, rs2\nf [rd] = f [rs1] + f [rs2]\n双精度浮点加(Floating-point Add, Double-Precision). R-type, RV32D and RV64D.\n把寄存器 f[rs1]和 f[rs2]中的双精度浮点数相加，并将舍入后的和写入 f[rd]。\n0000001 rs2 rs1 rm rd 1010011\n", "relevant": ["fadd.s", "fmadd.d"]}, {"name": "fadd.s", "content": "fadd.s rd, rs1, rs2\nf [rd] = f [rs1] + f [rs2]\n单精度浮点加(Floating-point Add, Single-Precision). R-type, RV32F and RV64F.\n把寄存器 f[rs1]和 f[rs2]中的单精度浮点数相加，并将舍入后的和写入 f[rd]。\n0000000 rs2 rs1 rm rd 1010011\n", "relevant": ["fadd.d", "fmadd.s"]}, {"name": "fclass.d", "content": "fclass.d rd, rs1, rs2\nx[rd] = classifyd(f[rs1])\n双精度浮点分类(Floating-point Classify, Double-Precision). R-type, RV32D and RV64D.\n把一个表示寄存器 f[rs1]中双精度浮点数类别的掩码写入 x[rd]中。关于如何解释写入 x[rd]的值，请参阅指令 fclass.s的介绍。\n1110001 00000 rs1 001 rd 1010011\n", "relevant": ["fclass.s"]}, {"name": "fclass.s", "content": "fclass.s rd, rs1, rs2\nx[rd] = classifys(f[rs1])\n单精度浮点分类(Floating-point Classify, Single-Precision). R-type, RV32F and RV64F.\n把一个表示寄存器 f[rs1]中单精度浮点数类别的掩码写入 x[rd]中。x[rd]中有且仅有一位被置上，见下表。\nx[rd]位 含义0 f [rs1]为−∞。\n1 f [rs1]是负规格化数。\n2 f [rs1]是负的非规格化数。\n3 f [rs1]是-0。\n4 f [rs1]是+0。\n5 f [rs1]是正的非规格化数。\n6 f [rs1]是正的规格化数。\n7 f [rs1]为+∞。\n8 f [rs1]是信号(signaling)NaN。\n9 f [rs1]是一个安静(quiet)NaN。\n1110000 00000 rs1 001 rd 1010011\n", "relevant": ["fclass.d"]}, {"name": "fcvt.d.l", "content": "fcvt.d.l rd, rs1, rs2\nf[rd] = f64s64(x[rs1])\n长整型向双精度浮点转换(Floating-point Convert to Double from Long). R-type, RV64D.\n把寄存器 x[rs1]中的 64 位二进制补码表示的整数转化为双精度浮点数，再写入 f[rd]中。\n1101001 00010 rs1 rm rd 1010011\n", "relevant": ["fcvt.d.lu", "fcvt.d.s", "fcvt.d.w", "fcvt.s.l"]}, {"name": "fcvt.d.lu", "content": "fcvt.d.lu rd, rs1, rs2\nf[rd] = f64u64(x[rs1])\n无符号长整型向双精度浮点转换(Floating-point Convert to Double from Unsigned Long). R-\ntype, RV64D.\n把寄存器 x[rs1]中的 64 位无符号整数转化为双精度浮点数，再写入 f[rd]中。\n1101001 00011 rs1 rm rd 1010011\n", "relevant": ["fcvt.d.l", "fcvt.d.wu", "fcvt.s.lu"]}, {"name": "fcvt.d.s", "content": "fcvt.d.s rd, rs1, rs2\nf[rd] = f64f32(f[rs1])\n单精度向双精度浮点转换(Floating-point Convert to Double from Single). R-type, RV32D and\nRV64D.\n把寄存器 f[rs1]中的单精度浮点数转化为双精度浮点数，再写入 f[rd]中。\n0100001 00000 rs1 rm rd 1010011\n", "relevant": ["fcvt.d.l", "fcvt.d.w", "fcvt.l.s", "fcvt.w.s"]}, {"name": "fcvt.d.w", "content": "fcvt.d.w rd, rs1, rs2\nf[rd] = f64s32(x[rs1])\n字向双精度浮点转换(Floating-point Convert to Double from Word). R-type, RV32D and RV64D.\n把寄存器 x[rs1]中的 32 位二进制补码表示的整数转化为双精度浮点数，再写入 f[rd]中。\n1101001 00000 rs1 rm rd 1010011\n", "relevant": ["fcvt.d.l", "fcvt.d.s", "fcvt.d.wu", "fcvt.s.w"]}, {"name": "fcvt.d.wu", "content": "fcvt.d.wu rd, rs1, rs2\nf[rd] = f64u32(x[rs1])\n无符号字向双精度浮点转换(Floating-point Convert to Double from Unsigned Word). R-type,\nRV32D and RV64D.\n把寄存器 x[rs1]中的 32 位无符号整数转化为双精度浮点数，再写入 f[rd]中。\n1101001 00001 rs1 rm rd 1010011\n", "relevant": ["fcvt.d.lu", "fcvt.d.w", "fcvt.s.wu"]}, {"name": "fcvt.l.d", "content": "fcvt.l.d rd, rs1, rs2\nx[rd] = s64f64(f[rs1])\n双精度浮点向长整型转换(Floating-point Convert to Long from Double). R-type, RV64D.\n把寄存器 f[rs1]中的双精度浮点数转化为 64 位二进制补码表示的整数，再写入 x[rd]中。\n1100001 00010 rs1 rm rd 1010011\n", "relevant": ["fcvt.l.s", "fcvt.lu.d", "fcvt.s.d", "fcvt.w.d"]}, {"name": "fcvt.l.s", "content": "fcvt.l.s rd, rs1, rs2\nx[rd] = s64f32(f[rs1])\n单精度浮点向长整型转换(Floating-point Convert to Long from Single). R-type, RV64F.\n把寄存器 f[rs1]中的单精度浮点数转化为 64 位二进制补码表示的整数，再写入 x[rd]中。\n1100000 00010 rs1 rm rd 1010011\n", "relevant": ["fcvt.d.s", "fcvt.l.d", "fcvt.lu.s", "fcvt.w.s"]}, {"name": "fcvt.lu.d", "content": "fcvt.lu.d rd, rs1, rs2\nx[rd] = u64f64(f[rs1])\n双精度浮点向无符号长整型转换(Floating-point Convert to Unsigned Long from Double). R-\ntype, RV64D.\n把寄存器 f[rs1]中的双精度浮点数转化为 64 位无符号整数，再写入 x[rd]中。\n1100001 00011 rs1 rm rd 1010011\n", "relevant": ["fcvt.l.d", "fcvt.lu.s", "fcvt.wu.d"]}, {"name": "fcvt.lu.s", "content": "fcvt.lu.s rd, rs1, rs2\nx[rd] = u64f32(f[rs1])\n单精度浮点向无符号长整型转换(Floating-point Convert to Unsigned Long from Single). R-type,\nRV64F.\n把寄存器 f[rs1]中的单精度浮点数转化为 64 位二进制补码表示的整数，再写入 x[rd]中。\n1100000 00011 rs1 rm rd 1010011\n", "relevant": ["fcvt.l.s", "fcvt.lu.d", "fcvt.wu.s"]}, {"name": "fcvt.s.d", "content": "fcvt.s.d rd, rs1, rs2\nf[rd] = f32f64(f[rs1])\n双精度向单精度浮点转换(Floating-point Convert to Single from Double). R-type, RV32D and\nRV64D.\n把寄存器 f[rs1]中的双精度浮点数转化为单精度浮点数，再写入 f[rd]中。\n0100000 00001 rs1 rm rd 1010011\n", "relevant": ["fcvt.l.d", "fcvt.s.l", "fcvt.s.w", "fcvt.w.d"]}, {"name": "fcvt.s.l", "content": "fcvt.s.l rd, rs1, rs2\nf[rd] = f32s64(x[rs1])\n长整型向单精度浮点转换(Floating-point Convert to Single from Long). R-type, RV64F.\n把寄存器 x[rs1]中的 64 位二进制补码表示的整数转化为单精度浮点数，再写入 f[rd]中。\n1101000 00010 rs1 rm rd 1010011\n", "relevant": ["fcvt.d.l", "fcvt.s.d", "fcvt.s.lu", "fcvt.s.w"]}, {"name": "fcvt.s.lu", "content": "fcvt.s.lu rd, rs1, rs2\nf[rd] = f32u64(x[rs1])\n无符号长整型向单精度浮点转换(Floating-point Convert to Single from Unsigned Long). R-type,\nRV64F.\n把寄存器 x[rs1]中的 64 位的无符号整数转化为单精度浮点数，再写入 f[rd]中。\n1101000 00011 rs1 rm rd 1010011\n", "relevant": ["fcvt.d.lu", "fcvt.s.l", "fcvt.s.wu"]}, {"name": "fcvt.s.w", "content": "fcvt.s.w rd, rs1, rs2\nf[rd] = f32s32(x[rs1])\n字向单精度浮点转换(Floating-point Convert to Single from Word). R-type, RV32F and RV64F.\n把寄存器 x[rs1]中的 32 位二进制补码表示的整数转化为单精度浮点数，再写入 f[rd]中。\n1101000 00000 rs1 rm rd 1010011\n", "relevant": ["fcvt.d.w", "fcvt.s.d", "fcvt.s.l", "fcvt.s.wu"]}, {"name": "fcvt.s.wu", "content": "fcvt.s.wu rd, rs1, rs2\nf[rd] = f32u32(x[rs1])\n无符号字向单精度浮点转换(Floating-point Convert to Single from Unsigned Word). R-type,\nRV32F and RV64F.\n把寄存器 x[rs1]中的 32 位无符号整数转化为单精度浮点数，再写入 f[rd]中。\n1101000 00001 rs1 rm rd 1010011\n", "relevant": ["fcvt.d.wu", "fcvt.s.lu", "fcvt.s.w"]}, {"name": "fcvt.w.d", "content": "fcvt.w.d rd, rs1, rs2\nx[rd] = sext(s32f64(f[rs1]))\n双精度浮点向字转换(Floating-point Convert to Word from Double). R-type, RV32D and RV64D.\n把寄存器 f[rs1]中的双精度浮点数转化为 32 位二进制补码表示的整数，再写入 x[rd]中。\n1100001 00000 rs1 rm rd 1010011\n", "relevant": ["fcvt.l.d", "fcvt.s.d", "fcvt.wu.d", "fcvt.w.s"]}, {"name": "fcvt.wu.d", "content": "fcvt.wu.d rd, rs1, rs2\nx[rd] = sext(u32f64(f[rs1]))\n双精度浮点向无符号字转换(Floating-point Convert to Unsigned Word from Double). R-type,\nRV32D and RV64D.\n把寄存器 f[rs1]中的双精度浮点数转化为 32 位无符号整数，再写入 x[rd]中。\n1100001 00001 rs1 rm rd 1010011\n", "relevant": ["fcvt.lu.d", "fcvt.w.d", "fcvt.wu.s"]}, {"name": "fcvt.w.s", "content": "fcvt.w.s rd, rs1, rs2\nx[rd] = sext(s32f32(f[rs1]))\n单精度浮点向字转换(Floating-point Convert to Word from Single). R-type, RV32F and RV64F.\n把寄存器 f[rs1]中的单精度浮点数转化为 32 位二进制补码表示的整数，再写入 x[rd]中。\n1100000 00000 rs1 rm rd 1010011\n", "relevant": ["fcvt.d.s", "fcvt.l.s", "fcvt.w.d", "fcvt.wu.s"]}, {"name": "fcvt.wu.s", "content": "fcvt.wu.s rd, rs1, rs2\nx[rd] = sext(u32f32(f[rs1]))\n单精度浮点向无符号字转换(Floating-point Convert to Unsigned Word from Single). R-type,\nRV32F and RV64F.\n把寄存器 f[rs1]中的单精度浮点数转化为 32 位无符号整数，再写入 x[rd]中。\n1100000 00001 rs1 rm rd 1010011\n", "relevant": ["fcvt.lu.s", "fcvt.wu.d", "fcvt.w.s"]}, {"name": "fdiv.d", "content": "fdiv.d rd, rs1, rs2\nf[rd] = f[rs1] ÷ f[rs2]\n双精度浮点除法(Floating-point Divide, Double-Precision). R-type, RV32D and RV64D.\n把寄存器 f[rs1]和 f[rs2]中的双精度浮点数相除，并将舍入后的商写入 f[rd]。\n0001101 rs2 rs1 rm rd 1010011\n", "relevant": ["fdiv.s"]}, {"name": "fdiv.s", "content": "fdiv.s rd, rs1, rs2\nf[rd] = f[rs1]  ÷  f[rs2]\n单精度浮点除法(Floating-point Divide, Single-Precision). R-type, RV32F and RV64F.\n把寄存器 f[rs1]和 f[rs2]中的单精度浮点数相除，并将舍入后的商写入 f[rd]。\n0001100 rs2 rs1 rm rd 1010011\n", "relevant": ["fdiv.d"]}, {"name": "fence", "content": "fence pred, succ\nFence(pred, succ)\n同步内存和I/O(Fence Memory and I/O). I-type, RV32I and RV64I.\n在后续指令中的内存和 I/O 访问对外部（例如其他线程）可见之前，使这条指令之前的内存及 I/O 访问对外部可见。比特中的第 3,2,1 和 0 位分别对应于设备输入，设备输出，内存读写。例如 fence r, rw，将前面读取与后面的读取和写入排序，使用 pred = 0010 和 succ = 0011\n进行编码。如果省略了参数，则表示 fence iorw, iorw，即对所有访存请求进行排序。\n0000 pred succ 00000 000 00000 0001111\n", "relevant": []}, {"name": "fence.i", "content": "fence.i\nFence(Store, Fetch) 同步指令流(Fence Instruction Stream). I-type, RV32I and RV64I.\n使对内存指令区域的读写，对后续取指令可见。\n000000000000 00000 001 00000 0001111\n", "relevant": []}, {"name": "feq.d", "content": "feq.d rd, rs1, rs2\nx[rd] = f[rs1] == f[rs2]\n双精度浮点相等(Floating-point Equals, Double-Precision). R-type, RV32D and RV64D.\n若寄存器 f[rs1]和 f[rs2]中的双精度浮点数相等，则在 x[rd]中写入 1，反之写 0。\n1010001 rs2 rs1 010 rd 1010011\n", "relevant": ["feq.s"]}, {"name": "feq.s", "content": "feq.s rd, rs1, rs2\nx[rd] = f[rs1] == f[rs2]\n单精度浮点相等(Floating-point Equals, Single-Precision). R-type, RV32F and RV64F.\n若寄存器 f[rs1]和 f[rs2]中的单精度浮点数相等，则在 x[rd]中写入 1，反之写 0。\n1010000 rs2 rs1 010 rd 1010011\n", "relevant": ["feq.d"]}, {"name": "fld", "content": "fld rd, offset(rs1)\nf[rd] = M[x[rs1] + sext(offset)][63:0]\n浮点加载双字(Floating-point Load Doubleword). I-type, RV32D and RV64D.\n从内存地址 x[rs1] + sign-extend(offset)中取双精度浮点数，并写入 f[rd]。\n压缩形式：c.fldsp rd, offset; c.fld rd, offset(rs1)\noffset[11:0] rs1 011 rd 0000111\n", "relevant": ["flw", "fsd", "ld"]}, {"name": "fle.d", "content": "fle.d rd, rs1, rs2\nx[rd] = f[rs1] ≤ f[rs2]\n双精度浮点小于等于(Floating-point Less Than or Equal, Double-Precision). R-type, RV32D and\nRV64D.\n若寄存器 f[rs1]中的双精度浮点数小于等于 f[rs2]中的双精度浮点数，则在 x[rd]中写入 1，反之写 0。\n1010001 rs2 rs1 000 rd 1010011\n", "relevant": ["fle.s", "fle.s"]}, {"name": "fle.s", "content": "fle.s rd, rs1, rs2\nx[rd] = f[rs1] ≤ f[rs2]\n单精度浮点小于等于(Floating-point Less Than or Equal, Single-Precision). R-type, RV32F and\nRV64F.\n若寄存器 f[rs1]中的单精度浮点数小于等于 f[rs2]中的单精度浮点数，则在 x[rd]中写入 1，反之写 0。\n1010000 rs2 rs1 000 rd 1010011\n", "relevant": ["fle.d", "fle.d"]}, {"name": "fle.d", "content": "fle.d rd, rs1, rs2\nx[rd] = f[rs1] < f[rs2]\n双精度浮点小于  (Floating-point Less Than, Double-Precision). R-type, RV32D and RV64D.\n若寄存器 f[rs1]中的双精度浮点数小于 f[rs2]中的双精度浮点数，则在 x[rd]中写入 1，反之写0。\n1010001 rs2 rs1 001 rd 1010011\n", "relevant": ["fle.s", "fle.s"]}, {"name": "fle.s", "content": "fle.s rd, rs1, rs2\nx[rd] = f[rs1] < f[rs2]\n单精度浮点小于  (Floating-point Less Than, Single-Precision). R-type, RV32F and RV64F.\n若寄存器 f[rs1]中的单精度浮点数小于 f[rs2]中的单精度浮点数，则在 x[rd]中写入 1，反之写0。\n1010000 rs2 rs1 001 rd 1010011\n", "relevant": ["fle.d", "fle.d"]}, {"name": "flw", "content": "flw rd, offset(rs1)\nf[rd] = M[x[rs1] + sext(offset)][31:0]\n浮点加载字(Floating-point Load Word). I-type, RV32F and RV64F.\n从内存地址 x[rs1] + sign-extend(offset)中取单精度浮点数，并写入 f[rd]。\n压缩形式：c.flwsp rd, offset; c.flw rd, offset(rs1)\noffset[11:0] rs1 010 rd 0000111\n", "relevant": ["fld", "fsw", "lw"]}, {"name": "fmadd.d", "content": "fmadd.d rd, rs1, rs2, rs3\nf[rd] = f[rs1]×f[rs2]+f[rs3]\n双精度浮点乘加(Floating-point Fused Multiply-Add, Double-Precision). R4-type, RV32D and\nRV64D.\n把寄存器 f[rs1]和 f[rs2]中的双精度浮点数相乘，并将未舍入的积和寄存器 f[rs3]中的双精度浮点数相加，将舍入后的双精度浮点数写入 f[rd]。\nrs3 01 rs2 rs1 rm rd 1000011\n", "relevant": ["fadd.d", "fmadd.s", "fnmadd.d"]}, {"name": "fmadd.s", "content": "fmadd.s rd, rs1, rs2, rs3\nf[rd] = f[rs1]×f[rs2]+f[rs3]\n单精度浮点乘加(Floating-point Fused Multiply-Add, Single-Precision).  R4-type,  RV32F  and\nRV64F.\n把寄存器 f[rs1]和 f[rs2]中的单精度浮点数相乘，并将未舍入的积和寄存器 f[rs3]中的单精度浮点数相加，将舍入后的单精度浮点数写入 f[rd]。\nrs3 00 rs2 rs1 rm rd 1000011\n", "relevant": ["fadd.s", "fmadd.d", "fnmadd.s"]}, {"name": "fmax.d", "content": "fmax.d rd, rs1, rs2\nf[rd] = max(f[rs1], f[rs2])\n双精度浮点最大值(Floating-point Maximum, Double-Precision). R-type, RV32D and RV64D.\n把寄存器 f[rs1]和 f[rs2]中的双精度浮点数中的较大值写入 f[rd]中。\n0010101 rs2 rs1 001 rd 1010011\n", "relevant": ["fmax.s"]}, {"name": "fmax.s", "content": "fmax.s rd, rs1, rs2\nf[rd] = max(f[rs1], f[rs2])\n单精度浮点最大值(Floating-point Maximum, Single-Precision). R-type, RV32F and RV64F.\n把寄存器 f[rs1]和 f[rs2]中的单精度浮点数中的较大值写入 f[rd]中。\n0010100 rs2 rs1 001 rd 1010011\n", "relevant": ["fmax.d"]}, {"name": "fmin.d", "content": "fmin.d rd, rs1, rs2\nf[rd] = min(f[rs1], f[rs2])\n双精度浮点最小值(Floating-point Minimum, Double-Precision). R-type, RV32D and RV64D.\n把寄存器 f[rs1]和 f[rs2]中的双精度浮点数中的较小值写入 f[rd]中。\n0010101 rs2 rs1 000 rd 1010011\n", "relevant": ["fmin.s"]}, {"name": "fmin.s", "content": "fmin.s rd, rs1, rs2\nf[rd] = min(f[rs1], f[rs2])\n单精度浮点最小值(Floating-point Minimum, Single-Precision). R-type, RV32F and RV64F.\n把寄存器 f[rs1]和 f[rs2]中的单精度浮点数中的较小值写入 f[rd]中。\n0010100 rs2 rs1 000 rd 1010011\n", "relevant": ["fmin.d"]}, {"name": "fmsub.d", "content": "fmsub.d rd, rs1, rs2, rs3\nf[rd] = f[rs1]×f[rs2]-f[rs3]\n双精度浮点乘减(Floating-point Fused Multiply-Subtract, Double-Precision). R4-type, RV32D\nand RV64D.\n把寄存器 f[rs1]和 f[rs2]中的双精度浮点数相乘，并将未舍入的积减去寄存器 f[rs3]中的双精度浮点数，将舍入后的双精度浮点数写入 f[rd]。\nrs3 01 rs2 rs1 rm rd 1000111\n", "relevant": ["fmsub.s", "fnmsub.d", "fsub.d"]}, {"name": "fmsub.s", "content": "fmsub.s rd, rs1, rs2, rs3\nf[rd] = f[rs1]×f[rs2]-f[rs3]\n单精度浮点乘减(Floating-point Fused Multiply-Subtarct, Single-Precision). R4-type, RV32F and\nRV64F.\n把寄存器 f[rs1]和 f[rs2]中的单精度浮点数相乘，并将未舍入的积减去寄存器 f[rs3]中的单精度浮点数，将舍入后的单精度浮点数写入 f[rd]。\nrs3 00 rs2 rs1 rm rd 1000111\n", "relevant": ["fmsub.d", "fnmsub.s", "fsub.s"]}, {"name": "fmul.d", "content": "fmul.d rd, rs1, rs2\nf[rd] = f[rs1] × f[rs2]\n双精度浮点乘(Floating-point Multiply, Double-Precision). R-type, RV32D and RV64D.\n把寄存器 f[rs1]和 f[rs2]中的双精度浮点数相乘，将舍入后的双精度结果写入 f[rd]中。\n0001001 rs2 rs1 rm rd 1010011\n", "relevant": ["fmul.s"]}, {"name": "fmul.s", "content": "fmul.s rd, rs1, rs2\nf[rd] = f[rs1] × f[rs2]\n单精度浮点乘(Floating-point Multiply, Single-Precision). R-type, RV32F and RV64F.\n把寄存器 f[rs1]和 f[rs2]中的单精度浮点数相乘，将舍入后的单精度结果写入 f[rd]中。\n0001000 rs2 rs1 rm rd 1010011\n", "relevant": ["fmul.d"]}, {"name": "fmv.d", "content": "fmv.d  rd, rs1\nf[rd] = f[rs1] 双精度浮点移动  (Floating-point Move).  伪指令(Pesudoinstruction), RV32D and RV64D.\n把寄存器 f[rs1]中的双精度浮点数复制到 f[rd]中，等同于 fsgnj.d rd, rs1, rs1.\n", "relevant": ["fmv.s"]}, {"name": "fmv.d.x", "content": "fmv.d.x rd, rs1, rs2\nf[rd] = x[rs1][63:0]\n双精度浮点移动(Floating-point Move Doubleword from Integer). R-type, RV64D.\n把寄存器 x[rs1]中的双精度浮点数复制到 f[rd]中。\n1111001 00000 rs1 000 rd 1010011\n", "relevant": []}, {"name": "fmv.s", "content": "fmv.s  rd, rs1\nf[rd] = f[rs1] 单精度浮点移动  (Floating-point Move).  伪指令(Pesudoinstruction), RV32F and RV64F.\n把寄存器 f[rs1]中的单精度浮点数复制到 f[rd]中，等同于 fsgnj.s rd, rs1, rs1.\n", "relevant": ["fmv.d"]}, {"name": "fmv.d.x", "content": "fmv.d.x rd, rs1, rs2\nf[rd] = x[rs1][31:0]\n单精度浮点移动(Floating-point Move Word from Integer). R-type, RV32F and RV64F.\n把寄存器 x[rs1]中的单精度浮点数复制到 f[rd]中。\n1111000 00000 rs1 000 rd 1010011\n", "relevant": []}, {"name": "fmv.x.d", "content": "fmv.x.d rd, rs1, rs2\nx[rd] = f[rs1][63:0]\n双精度浮点移动(Floating-point Move Doubleword to Integer). R-type, RV64D.\n把寄存器 f[rs1]中的双精度浮点数复制到 x[rd]中。\n1110001 00000 rs1 000 rd 1010011\n", "relevant": ["fmv.x.w"]}, {"name": "fmv.x.w", "content": "fmv.x.w rd, rs1, rs2\nx[rd] = sext(f[rs1][31:0])\n单精度浮点移动(Floating-point Move Word to Integer). R-type, RV32F and RV64F.\n把寄存器 f[rs1]中的单精度浮点数复制到 x[rd]中，对于 RV64F，将结果进行符号扩展。\n1110000 00000 rs1 000 rd 1010011\n", "relevant": ["fmv.x.d"]}, {"name": "fneg.d", "content": "fneg.d  rd, rs1\nf[rd] = -f[rs1] 双精度浮点取反  (Floating-point Negate).  伪指令(Pesudoinstruction), RV32D and RV64D.\n把寄存器 f[rs1]中的双精度浮点数取反后写入 f[rd]中，等同于 fsgnjn.d rd, rs1, rs1.\n", "relevant": ["fneg.s"]}, {"name": "fneg.s", "content": "fneg.s  rd, rs1\nf[rd] = -f[rs1] 单精度浮点取反  (Floating-point Negate).  伪指令(Pesudoinstruction), RV32F and RV64F.\n把寄存器 f[rs1]中的单精度浮点数取反后写入 f[rd]中，等同于 fsgnjn.s rd, rs1, rs1.\n", "relevant": ["fneg.d"]}, {"name": "fnmadd.d", "content": "fnmadd.d rd, rs1, rs2, rs3\nf[rd] = f[rs1]×f[rs2]+f[rs3]\n双精度浮点乘取反加(Floating-point Fused Negative Multiply-Add, Double-Precision). R4-type,\nRV32D and RV64D.\n把寄存器 f[rs1]和 f[rs2]中的双精度浮点数相乘，将结果取反，并将未舍入的积和寄存器 f[rs3]\n中的双精度浮点数相加，将舍入后的双精度浮点数写入 f[rd]。\nrs3 01 rs2 rs1 rm rd 1001111\n", "relevant": ["fmadd.d", "fnmadd.s"]}, {"name": "fnmadd.s", "content": "fnmadd.s rd, rs1, rs2, rs3\nf[rd] = -f[rs1]_f[rs2]-f[rs3]\n单精度浮点乘取反加(Floating-point Fused Negative Multiply-Add, Single-Precision). R4-type,\nRV32F and RV64F.\n把寄存器 f[rs1]和 f[rs2]中的单精度浮点数相乘，将结果取反，并将未舍入的积和寄存器 f[rs3]\n中的单精度浮点数相加，将舍入后的单精度浮点数写入 f[rd]。\nrs3 00 rs2 rs1 rm rd 1001111\n", "relevant": ["fmadd.s", "fnmadd.d"]}, {"name": "fnmsub.d", "content": "fnmsub.d rd, rs1, rs2, rs3\nf[rd] = -f[rs1]_f[rs2]+f[rs3]\n双精度浮点乘取反减(Floating-point Fused Negative Multiply-Subtract, Double-Precision). R4-\ntype, RV32D and RV64D.\n把寄存器 f[rs1]和 f[rs2]中的双精度浮点数相乘，将结果取反，并将未舍入的积减去寄存器f[rs3]中的双精度浮点数，将舍入后的双精度浮点数写入 f[rd]。\nrs3 01 rs2 rs1 rm rd 1001011\n", "relevant": ["fmsub.d", "fnmsub.s"]}, {"name": "fnmsub.s", "content": "fnmsub.s rd, rs1, rs2, rs3\nf[rd] = -f[rs1]×f[rs2]+f[rs3]\n单精度浮点乘取反减(Floating-point Fused Negative Multiply-Subtract, Single-Precision). R4-\ntype, RV32F and RV64F.\n把寄存器 f[rs1]和 f[rs2]中的单精度浮点数相乘，将结果取反，并将未舍入的积减去寄存器f[rs3]中的单精度浮点数，将舍入后的单精度浮点数写入 f[rd]。\nrs3 00 rs2 rs1 rm rd 1001011\n", "relevant": ["fmsub.s", "fnmsub.d"]}, {"name": "frcsr", "content": "frcsr  rd\nx[rd] = CSRs[fcsr]\n浮点读控制状态寄存器  (Floating-point  Read  Control  and  Status  Register).  伪指令(Pseudoinstruction), RV32F and RV64F.\n把浮点控制状态寄存器的值写入 x[rd]，等同于 csrrs rd, fcsr, x0.\n", "relevant": ["fscsr"]}, {"name": "frflags", "content": "frflags  rd\nx[rd] = CSRs[fflags]\n浮点读异常标志  (Floating-point Read Exception Flags).  伪指令(Pseudoinstruction), RV32F and\nRV64F.\n把浮点异常标志的值写入 x[rd]，等同于 csrrs rd, fflags, x0.\n", "relevant": ["fsflags"]}, {"name": "frrm", "content": "frrm  rd\nx[rd] = CSRs[frm]\n浮点读舍入模式  (Floating-point Read Rounding Mode).  伪指令(Pseudoinstruction), RV32F and\nRV64F.\n把浮点舍入模式的值写入 x[rd]，等同于 csrrs rd, frm, x0.\n", "relevant": ["fsrm"]}, {"name": "fscsr", "content": "fscsr  rd, rs1\nt = CSRs[fcsr]; CSRs[fcsr] = x[rs1]; x[rd] = t 浮点换出控制状态寄存器  (Floating-point  Swap  Control  and  Status  Register).  伪指令(Pseudoinstruction), RV32F and RV64F.\n把寄存器 x[rs1]的值写入浮点控制状态寄存器，并将浮点控制状态寄存器的原值写入 x[rd]，\n等同于 csrrw rd, fcsr, rs1。rd 默认为 x0。\n", "relevant": ["frcsr"]}, {"name": "fsd", "content": "fsd rs2, offset(rs1)\nM[x[rs1] + sext(offset)] = f[rs2][63:0]\n双精度浮点存储(Floating-point Store Doubleword). S-type, RV32D and RV64D.\n将寄存器 f[rs2]中的双精度浮点数存入内存地址 x[rs1] + sign-extend(offset)中。\n压缩形式：c.fsdsp rs2, offset; c.fsd rs2, offset(rs1)\noffset[11:5] rs2 rs1 011 offset[4:0] 0100111\n", "relevant": ["fld", "fsw", "sd"]}, {"name": "fsflags", "content": "fsflags  rd, rs1\nt = CSRs[fflags]; CSRs[fflags] = x[rs1]; x[rd] = t 浮点换出异常标志  (Floating-point Swap Exception Flags).  伪指令(Pseudoinstruction), RV32F\nand RV64F.\n把寄存器 x[rs1]的值写入浮点异常标志寄存器，并将浮点异常标志寄存器的原值写入 x[rd]，\n等同于 csrrw rd, fflags, rs1。rd 默认为 x0。\n", "relevant": ["frflags"]}, {"name": "fsgnj.d", "content": "fsgnj.d rd, rs1, rs2\nf[rd] = {f[rs2][63], f[rs1][62:0]}\n双精度浮点符号注入(Floating-point Sign Inject, Double-Precision). R-type, RV32D and RV64D.\n用 f[rs1]指数和有效数以及 f[rs2]的符号的符号位，来构造一个新的双精度浮点数，并将其写入 f[rd]。\n0010001 rs2 rs1 000 rd 1010011\n", "relevant": ["fsgnj.s", "fsgnjn.d", "fsgnjx.d"]}, {"name": "fsgnj.s", "content": "fsgnj.s rd, rs1, rs2\nf[rd] = {f[rs2][31], f[rs1][30:0]}\n单精度浮点符号注入(Floating-point Sign Inject, Single-Precision). R-type, RV32F and RV64F.\n用 f[rs1]指数和有效数以及 f[rs2]的符号的符号位，来构造一个新的单精度浮点数，并将其写入 f[rd]。\n0010000 rs2 rs1 000 rd 1010011\n", "relevant": ["fsgnj.d", "fsgnjn.s", "fsgnjx.s"]}, {"name": "fsgnjn.d", "content": "fsgnjn.d rd, rs1, rs2\nf[rd] = {~f[rs2][63], f[rs1][62:0]}\n双精度浮点符号取反注入(Floating-point Sign Inject-Negate, Double-Precision). R-type, RV32D\nand RV64D.\n用 f[rs1]指数和有效数以及 f[rs2]的符号的符号位取反，来构造一个新的双精度浮点数，并将其写入 f[rd]。\n0010001 rs2 rs1 001 rd 1010011\n", "relevant": ["fsgnj.d", "fsgnjn.s", "fsgnjx.d"]}, {"name": "fsgnjn.s", "content": "fsgnjn.s rd, rs1, rs2\nf[rd] = {~f[rs2][31], f[rs1][30:0]}\n单精度浮点符号取反注入(Floating-point Sign Inject-Negate, Single-Precision). R-type, RV32F\nand RV64F.\n用 f[rs1]指数和有效数以及 f[rs2]的符号的符号位取反，来构造一个新的单精度浮点数，并将其写入 f[rd]。\n0010000 rs2 rs1 001 rd 1010011\n", "relevant": ["fsgnj.s", "fsgnjn.d", "fsgnjx.s"]}, {"name": "fsgnjx.d", "content": "fsgnjx.d rd, rs1, rs2\nf[rd] = {f[rs1][63] ^ f[rs2][63], f[rs1][62:0]}\n双精度浮点符号异或注入(Floating-point Sign Inject-XOR, Double-Precision). R-type, RV32D\nand RV64D.\n用 f[rs1]指数和有效数以及 f[rs1]和 f[rs2]的符号的符号位异或，来构造一个新的双精度浮点数，并将其写入 f[rd]。\n0010001 rs2 rs1 010 rd 1010011\n", "relevant": ["fsgnj.d", "fsgnjn.d", "fsgnjx.s"]}, {"name": "fsgnjx.s", "content": "fsgnjx.s rd, rs1, rs2\nf[rd] = {f[rs1][31] ^ f[rs2][31], f[rs1][30:0]}\n单精度浮点符号异或注入(Floating-point Sign Inject-XOR, Single-Precision). R-type, RV32F\nand RV64F.\n用 f[rs1]指数和有效数以及 f[rs1]和 f[rs2]的符号的符号位异或，来构造一个新的单精度浮点数，并将其写入 f[rd]。\n0010000 rs2 rs1 010 rd 1010011\n", "relevant": ["fsgnj.s", "fsgnjn.s", "fsgnjx.d"]}, {"name": "fsqrt.d", "content": "fsqrt.d rd, rs1, rs2\nf[rd] =√ f[rs1]\n双精度浮点平方根(Floating-point Square Root, Double-Precision). R-type, RV32D and RV64D.\n将 f[rs1]中的双精度浮点数的平方根舍入和写入 f[rd]。\n0101101 00000 rs1 rm rd 1010011\n", "relevant": ["fsqrt.s"]}, {"name": "fsqrt.s", "content": "fsqrt.s rd, rs1, rs2\nf[rd] =√ f[rs1]\n单精度浮点平方根(Floating-point Square Root, Single-Precision). R-type, RV32F and RV64F.\n将 f[rs1]中的单精度浮点数的平方根舍入和写入 f[rd]。\n0101100 00000 rs1 rm rd 1010011\n", "relevant": ["fsqrt.d"]}, {"name": "fsrm", "content": "fsrm  rd, rs1\nt = CSRs[frm]; CSRs[frm] = x[rs1]; x[rd] = t\n浮点换出舍入模式  (Floating-point Swap Rounding Mode).  伪指令(Pseudoinstruction), RV32F\nand RV64F.\n把寄存器 x[rs1]的值写入浮点舍入模式寄存器，并将浮点舍入模式寄存器的原值写入 x[rd]，\n等同于 csrrw rd, frm, rs1。rd 默认为 x0。\n", "relevant": ["frrm"]}, {"name": "fsub.d", "content": "fsub.d rd, rs1, rs2\nf[rd] = f[rs1] - f[rs2]\n双精度浮点减(Floating-point Subtract, Double-Precision). R-type, RV32D and RV64D.\n把寄存器 f[rs1]和 f[rs2]中的双精度浮点数相减，并将舍入后的差写入 f[rd]。\n0000101 rs2 rs1 rm rd 1010011\n", "relevant": ["fmsub.d", "fsub.s"]}, {"name": "fsub.s", "content": "fsub.s rd, rs1, rs2\nf[rd] = f[rs1] - f[rs2]\n单精度浮点减(Floating-point Subtract, Single-Precision). R-type, RV32F and RV64F.\n把寄存器 f[rs1]和 f[rs2]中的单精度浮点数相减，并将舍入后的差写入 f[rd]。\n0000100 rs2 rs1 rm rd 1010011\n", "relevant": ["fmsub.s", "fsub.d"]}, {"name": "fsw", "content": "fsw rs2, offset(rs1)\nM[x[rs1] + sext(offset)] = f[rs2][31:0]\n单精度浮点存储(Floating-point Store Word). S-type, RV32F and RV64F.\n将寄存器 f[rs2]中的单精度浮点数存入内存地址 x[rs1] + sign-extend(offset)中。\n压缩形式：c.fswsp rs2, offset; c.fsw rs2, offset(rs1)\noffset[11:5] rs2 rs1 010 offset[4:0] 0100111\n", "relevant": ["flw", "fsd", "sw"]}, {"name": "j", "content": "j  offset\npc += sext(offset)\n跳转  (Jump).  伪指令(Pseudoinstruction), RV32I and RV64I.\n把 pc 设置为当前值加上符号位扩展的 offset，等同于 jal x0, offset.\n", "relevant": ["jr"]}, {"name": "jal", "content": "jal rd, offset\nx[rd] = pc+4; pc += sext(offset)\n跳转并链接  (Jump and Link). J-type, RV32I and RV64I.\n把下一条指令的地址(pc+4)，然后把 pc设置为当前值加上符号位扩展的 offset。rd 默认为 x1。\n压缩形式：c.j offset; c.jal offset\noffset[20|10:1|11|19:12] rd 1101111\n", "relevant": ["jalr"]}, {"name": "jalr", "content": "jalr rd, offset(rs1)\nt =pc+4; pc=(x[rs1]+sext(offset))&~1; x[rd]=t\n跳转并寄存器链接  (Jump and Link Register). I-type, RV32I and RV64I.\n把 pc 设置为 x[rs1] + sign-extend(offset)，把计算出的地址的最低有效位设为 0，并将原 pc+4的值写入 f[rd]。rd 默认为 x1。\n压缩形式：c.jr rs1; c.jalr rs1\noffset[11:0] rs1 010 rd 1100111\n", "relevant": ["jal"]}, {"name": "jr", "content": "jr  rs1\npc = x[rs1] 寄存器跳转  (Jump Register).  伪指令(Pseudoinstruction), RV32I and RV64I.\n把 pc 设置为 x[rs1]，等同于 jalr x0, 0(rs1)。\n", "relevant": ["j", "or"]}, {"name": "la", "content": "la  rd, symbol\nx[rd] = &symbol\n地址加载  (Load Address).  伪指令(Pseudoinstruction), RV32I and RV64I.\n将 symbol 的地址加载到 x[rd]中。当编译位置无关的代码时，它会被扩展为对全局偏移量表(Global Offset Table)的加载。对于 RV32I，等同于执行 auipc  rd, offsetHi，然后是 lw  rd，\noffsetLo(rd);对于 RV64I，则 等同于 auipc rd，offsetHi和 ld rd, offsetLo(rd)。如果 offset 过大，\n开始的算加载地址的指令会变成两条，先是 auipc rd, offsetHi然后是 addi rd, rd, offsetLo。\n", "relevant": ["lb", "ld", "lh", "li", "lla", "lw"]}, {"name": "lb", "content": "lb rd, offset(rs1)\nx[rd] = sext(M[x[rs1] + sext(offset)][7:0])\n字节加载  (Load Byte). I-type, RV32I and RV64I.\n从地址 x[rs1] + sign-extend(offset)读取一个字节，经符号位扩展后写入 x[rd]。\noffset[11:0] rs1 000 rd 0000011\n", "relevant": ["la", "lbu", "ld", "lh", "li", "lw", "sb"]}, {"name": "lbu", "content": "lbu rd, offset(rs1)\nx[rd] = M[x[rs1] + sext(offset)][7:0]\n无符号字节加载  (Load Byte, Unsigned). I-type, RV32I and RV64I.\n从地址 x[rs1] + sign-extend(offset)读取一个字节，经零扩展后写入 x[rd]。\noffset[11:0] rs1 100 rd 0000011\n", "relevant": ["lb", "lhu", "lwu"]}, {"name": "ld", "content": "ld rd, offset(rs1)\nx[rd] = M[x[rs1] + sext(offset)][63:0]\n双字加载  (Load Doubleword). I-type, RV32I and RV64I.\n从地址 x[rs1] + sign-extend(offset)读取八个字节，写入 x[rd]。\n压缩形式：c.ldsp rd, offset; c.ld rd, offset(rs1)\noffset[11:0] rs1 011 rd 0000011\n", "relevant": ["fld", "la", "lb", "lh", "li", "lw", "sd"]}, {"name": "lh", "content": "lh rd, offset(rs1)\nx[rd] = sext(M[x[rs1] + sext(offset)][15:0])\n半字加载  (Load Halfword). I-type, RV32I and RV64I.\n从地址 x[rs1] + sign-extend(offset)读取两个字节，经符号位扩展后写入 x[rd]。\noffset[11:0] rs1 001 rd 0000011\n", "relevant": ["la", "lb", "ld", "lhu", "li", "lw", "sh"]}, {"name": "lhu", "content": "lhu rd, offset(rs1)\nx[rd] = M[x[rs1] + sext(offset)][15:0]\n无符号半字加载  (Load Halfword, Unsigned). I-type, RV32I and RV64I.\n从地址 x[rs1] + sign-extend(offset)读取两个字节，经零扩展后写入 x[rd]。\noffset[11:0] rs1 101 rd 0000011\n", "relevant": ["lbu", "lh", "lwu"]}, {"name": "li", "content": "li  rd, immediate\nx[rd] = immediate 立即数加载  (Load Immediate).  伪指令(Pseudoinstruction), RV32I and RV64I.\n使用尽可能少的指令将常量加载到 x[rd]中。在 RV32I 中，它等同于执行 lui和/或 addi；对于 RV64I，会扩展为这种指令序列 lui, addi, slli, addi, slli, addi ,slli, addi。\n", "relevant": ["la", "lb", "ld", "lh", "lw", "lui"]}, {"name": "lla", "content": "lla  rd, symbol\nx[rd] = &symbol 本地地址加载  (Load Local Address).  伪指令(Pseudoinstruction), RV32I and RV64I.\n将 symbol 的地址加载到 x[rd]中。等同于执行 auipc rd, offsetHi，然后是 addi rd, rd, offsetLo。\n", "relevant": ["la"]}, {"name": "lr.d", "content": "lr.d rd, (rs1)\nx[rd] = LoadReserved64(M[x[rs1]])\n加载保留双字(Load-Reserved Doubleword). R-type, RV64A.\n从内存中地址为 x[rs1]中加载八个字节，写入 x[rd]，并对这个内存双字注册保留。\n00010 aq rl 00000 rs1 011 rd 0101111\n", "relevant": ["lr.w"]}, {"name": "lr.w", "content": "lr.w rd, (rs1)\nx[rd] = LoadReserved32(M[x[rs1]])\n加载保留字(Load-Reserved Word). R-type, RV32A and RV64A.\n从内存中地址为 x[rs1]中加载四个字节，符号位扩展后写入 x[rd]，并对这个内存字注册保留。\n00010 aq rl 00000 rs1 010 rd 0101111\n", "relevant": ["lr.d"]}, {"name": "lw", "content": "lw rd, offset(rs1)\nx[rd] = sext(M[x[rs1] + sext(offset)][31:0])\n字加载  (Load Word). I-type, RV32I and RV64I.\n从地址 x[rs1] + sign-extend(offset)读取四个字节，写入 x[rd]。对于 RV64I，结果要进行符号位扩展。\n压缩形式：c.lwsp rd, offset; c.lw rd, offset(rs1)\noffset[11:0] rs1 010 rd 0000011\n", "relevant": ["flw", "la", "lb", "ld", "lh", "li", "lwu", "sw"]}, {"name": "lwu", "content": "lwu rd, offset(rs1)\nx[rd] = M[x[rs1] + sext(offset)][31:0]\n无符号字加载  (Load Word, Unsigned). I-type, RV64I.\n从地址 x[rs1] + sign-extend(offset)读取四个字节，零扩展后写入 x[rd]。\noffset[11:0] rs1 110 rd 0000011\n", "relevant": ["lbu", "lhu", "lw"]}, {"name": "lui", "content": "lui  rd, immediate\nx[rd] = sext(immediate[31:12] << 12) 高位立即数加载  (Load Upper Immediate). U-type, RV32I and RV64I.\n将符号位扩展的 20 位立即数 immediate 左移 12 位，并将低 12 位置零，写入 x[rd]中。\n压缩形式：c.lui rd, imm\nimmediate[31:12] rd 0110111\n", "relevant": ["li"]}, {"name": "mret", "content": "mret\nExceptionReturn(Machine)\n机器模式异常返回(Machine-mode Exception Return). R-type, RV32I and RV64I 特权架构从机器模式异常处理程序返回。将 pc 设置为 CSRs[mepc], 将特权级设置成CSRs[mstatus].MPP, CSRs[mstatus].MIE 置成 CSRs[mstatus].MPIE,  并且将CSRs[mstatus].MPIE 为 1;并且，如果支持用户模式，则将 CSR [mstatus].MPP 设置为 0。\n0011000 00010 00000 000 00000 1110011\n", "relevant": ["ret", "sret"]}, {"name": "mul", "content": "mul rd, rs1, rs2\nx[rd]=x[rs1]×x[rs2]\n乘(Multiply). R-type, RV32M and RV64M.\n把寄存器 x[rs2]乘到寄存器 x[rs1]上，乘积写入 x[rd]。忽略算术溢出。\n0000001 rs2 rs1 000 rd 0110011\n", "relevant": ["mulh", "mulw"]}, {"name": "mulh", "content": "mulh rd, rs1, rs2\nx[rd]=(x[rs1] 𝑠 ×𝑠 x[rs2])≫𝑠 XLEN\n高位乘(Multiply High). R-type, RV32M and RV64M.\n把寄存器 x[rs2]乘到寄存器 x[rs1]上，都视为 2 的补码，将乘积的高位写入 x[rd]。\n0000001 rs2 rs1 001 rd 0110011\n", "relevant": ["mul", "mulhu", "mulw"]}, {"name": "mulhsu", "content": "mulhsu rd, rs1, rs2\nx[rd]=(x[rs1] 𝑠 ×𝑢 x[rs2])≫𝑠 XLEN\n高位有符号-无符号乘(Multiply High Signed-Unsigned). R-type, RV32M and RV64M.\n把寄存器 x[rs2]乘到寄存器 x[rs1]上，x[rs1]为 2 的补码，x[rs2]为无符号数，将乘积的高位写入 x[rd]。\n0000001 rs2 rs1 010 rd 0110011\n", "relevant": ["mulhu"]}, {"name": "mulhu", "content": "mulhu rd, rs1, rs2\nx[rd]=(x[rs1] 𝑢 ×𝑢 x[rs2])≫𝑢 XLEN\n高位无符号乘(Multiply High Unsigned). R-type, RV32M and RV64M.\n把寄存器 x[rs2]乘到寄存器 x[rs1]上，x[rs1]、x[rs2]均为无符号数，将乘积的高位写入 x[rd]。\n0000001 rs2 rs1 011 rd 0110011\n", "relevant": ["mulh", "mulhsu"]}, {"name": "mulw", "content": "mulw rd, rs1, rs2\nx[rd]=sext((x[rs1]×x[rs2])[31:0])\n乘字(Multiply Word). R-type, RV64M only.\n把寄存器 x[rs2]乘到寄存器 x[rs1]上，乘积截为 32 位，进行有符号扩展后写入 x[rd]。忽略算术溢出。\n0000001 rs2 rs1 000 rd 0111011\n", "relevant": ["mul", "mulh"]}, {"name": "mv", "content": "mv rd, rs1\nx[rd]=x[rs1]\n移动(Move).  伪指令(Pseudoinstruction), RV32I and RV64I.\n把寄存器 x[rs1]复制到 x[rd]中。实际被扩展为 addi rd, rs1, 0\n", "relevant": []}, {"name": "neg", "content": "neg rd, rs2\nx[rd]=−x[rs2]\n取反(Negate).  伪指令(Pseudoinstruction), RV32I and RV64I.\n把寄存器 x[rs2]的二进制补码写入 x[rd]。实际被扩展为 sub rd, x0, rs2。\n", "relevant": ["negw"]}, {"name": "negw", "content": "negw rd, rs2\nx[rd]=sext((−x[rs2])[31:0])\n取非字(Negate Word).  伪指令(Pseudoinstruction), RV64I only.\n计算寄存器 x[rs2]对于 2 的补码，结果截为 32 位，进行符号扩展后写入 x[rd]。实际被扩展为 subw rd, x0, rs2。\n", "relevant": ["neg"]}, {"name": "nop", "content": "nop\n无操作(No operation).  伪指令(Pseudoinstruction), RV32I and RV64I.\n将 pc 推进到下一条指令。实际被扩展为 addi x0, x0, 0。\n", "relevant": ["not"]}, {"name": "not", "content": "not rd, rs1\nx[rd]=~x[rs1]\n取反(NOT).  伪指令(Pseudoinstruction), RV32I and RV64I.\n把寄存器 x[rs1]对于 1 的补码（即按位取反的值）写入 x[rd]。实际被扩展为 xori rd, rs1, -1。\n", "relevant": ["nop"]}, {"name": "or", "content": "or rd, rs1, rs2\nx[rd]=x[rs1] | 𝑥[𝑟𝑠2]\n取或(OR). R-type, RV32I and RV64I.\n把寄存器 x[rs1]和寄存器 x[rs2]按位取或，结果写入 x[rd]。\n压缩形式：c.or rd, rs2\n0000000 rs2 rs1 110 rd 0110011\n", "relevant": ["jr", "ori", "xor"]}, {"name": "ori", "content": "ori rd, rs1, immediate\nx[rd]=x[rs1] | sext(immediate)\n立即数取或(OR Immediate). R-type, RV32I and RV64I.\n把寄存器 x[rs1]和有符号扩展的立即数 immediate 按位取或，结果写入 x[rd]。\n压缩形式：c.or rd, rs2\nImmediate[11:0] rs2 rs1 110 rd 0010011\n", "relevant": ["or"]}, {"name": "rdcycle", "content": "rdcycle rd\nx[rd]=CSRS[cycle]\n读周期计数器(Read Cycle Counter).  伪指令(Pseudoinstruction), RV32I and RV64I.\n把周期数写入 x[rd]。实际被扩展为 csrrs rd, cycle, x0。\n", "relevant": ["rdcycleh"]}, {"name": "rdcycleh", "content": "rdcycleh rd\nx[rd]=CSRs[cycleh]\n读周期计数器高位(Read Cycle Counte High).  伪指令(Pseudoinstruction), RV32I only.\n把周期数右移 32 位后写入 x[rd]。实际被扩展为 csrrs rd, cycleh, x0。\n", "relevant": ["rdcycle"]}, {"name": "rdinstret", "content": "rdinstret rd\nx[rd]=CSRs[instret]\n读已完成指令计数器(Read Instruction-Retired Counter).  伪指令(Pseudoinstruction), RV32I and\nRV64I.\n把已完成指令数写入 x[rd]。实际被扩展为 csrrs rd, instret, x0。\n", "relevant": ["rdinstreth"]}, {"name": "rdinstreth", "content": "rdinstreth rd\nx[rd]=CSRs[instreth]\n读已完成指令计数器高位(Read Instruction-Retired Counter High).  伪指令(Pseudoinstruction),\nRV32I only.\n把已完成指令数右移 32 位后写入 x[rd]。实际被扩展为 csrrs rd, instreth, x0。\n", "relevant": ["rdinstret"]}, {"name": "rdtime", "content": "rdtime rd\nx[rd]=CSRs[time]\n读取时间(Read Time).  伪指令(Pseudoinstruction), RV32I and RV64I.\n把当前时间写入 x[rd]，时间频率与平台相关。实际被扩展为 csrrs rd, time, x0。\n", "relevant": ["rdtimeh"]}, {"name": "rdtimeh", "content": "rdtimeh rd\nx[rd]=CSRs[timeh]\n读取时间高位(Read Time High).  伪指令(Pseudoinstruction), RV32I only.\n把当前时间右移 32 位后写入 x[rd]，时间频率与平台相关。实际被扩展为 csrrs rd, timeh, x0。\n", "relevant": ["rdtime"]}, {"name": "rem", "content": "rem rd, rs1, rs2\nx[rd]=x[rs1] %𝑠 x[rs2]\n求余数(Remainder). R-type, RV32M and RV64M.\nx[rs1]除以 x[rs2]，向 0 舍入，都视为 2 的补码，余数写入 x[rd]。\n0000001 rs2 rs1 110 rd 0110011\n", "relevant": ["remu", "remw", "ret"]}, {"name": "remu", "content": "remu rd, rs1, rs2\nx[rd]=x[rs1] %𝑢 x[rs2]\n求无符号数的余数(Remainder, Unsigned). R-type, RV32M and RV64M.\nx[rs1]除以 x[rs2]，向 0 舍入，都视为无符号数，余数写入 x[rd]。\n0000001 rs2 rs1 111 rd 0110011\n", "relevant": ["rem", "remuw", "remw"]}, {"name": "remuw", "content": "remuw rd, rs1, rs2\nx[rd]=sext(x[rs1][31:0] %𝑢 x[rs2][31:0])\n求无符号数的余数字(Remainder Word, Unsigned). R-type, RV64M only.\nx[rs1]的低 32 位除以 x[rs2]的低 32 位，向 0 舍入，都视为无符号数，将余数的有符号扩展写入 x[rd]。\n0000001 rs2 rs1 111 rd 0111011\n", "relevant": ["remu", "remw"]}, {"name": "remw", "content": "remw rd, rs1, rs2\nx[rd]=sext(x[rs1][31:0] %𝑠 x[rs2][31:0])\n求余数字(Remainder Word). R-type, RV64M only.\nx[rs1]的低 32 位除以 x[rs2]的低 32 位，向 0 舍入，都视为 2 的补码，将余数的有符号扩展写入 x[rd]。\n0000001 rs2 rs1 110 rd 0111011\n", "relevant": ["rem", "remu", "remuw"]}, {"name": "ret", "content": "ret\npc=x[1]\n返回(Return).  伪指令(Pseudoinstruction), RV32I and RV64I.\n从子过程返回。实际被扩展为 jalr x0, 0(x1)。\n", "relevant": ["mret", "rem", "sret"]}, {"name": "sb", "content": "sb rs2, offset(rs1)\nM[x[rs1]+sext(offset)=x[rs2][7:0]\n存字节(Store Byte). S-type, RV32I and RV64I.\n将 x[rs2]的低位字节存入内存地址 x[rs1]+sign-extend(offset)。\noffset[11:5] rs2 rs1 000 offset[4:0] 0100011\n", "relevant": ["lb", "sd", "sh", "sw", "sub"]}, {"name": "sc.d", "content": "sc.d rd, rs2, (rs1)\nx[rd]=StoreConditonal64(M[x[rs1],x[rs2])\n条件存入双字(Store-Conditional Doubleword). R-type, RV64A only.\n如果内存地址 x[rs1]上存在加载保留，将 x[rs2]寄存器中的 8 字节数存入该地址。如果存入成功，向寄存器 x[rd]中存入 0，否则存入一个非 0 的错误码。\n00011 aq rl rs2 rs1 011 rd 0101111\n", "relevant": ["sc.w"]}, {"name": "sc.w", "content": "sc.w rd, rs2, (rs1)\nx[rd]=StoreConditonal32(M[x[rs1],x[rs2])\n条件存入字(Store-Conditional Word). R-type, RV32A and RV64A.\n内存地址 x[rs1]上存在加载保留，将 x[rs2]寄存器中的 4 字节数存入该地址。如果存入成功，\n向寄存器 x[rd]中存入 0，否则存入一个非 0 的错误码。\n00011 aq rl rs2 rs1 010 rd 0101111\n", "relevant": ["sc.d"]}, {"name": "sd", "content": "sd rs2, offset(rs1)\nM[x[rs1]+sext(offset)=x[rs2][63:0]\n存双字(Store Doubleword). S-type, RV64I only.\n将 x[rs2]中的 8 字节存入内存地址 x[rs1]+sign-extend(offset)。\n压缩形式：c.sdsp rs2, offset; c.sd rs2, offset(rs1)\noffset[11:5] rs2 rs1 011 offset[4:0] 0100011\n", "relevant": ["fsd", "ld", "sb", "sh", "sw"]}, {"name": "seqz", "content": "seqz rd, rs1\nx[rd]=(x[rs1]==0)\n等于0 则置位(Set if Equal to Zero).  伪指令(Pseudoinstruction), RV32I and RV64I.\n如果 x[rs1]等于 0，向 x[rd]写入 1，否则写入 0。实际被扩展为 sltiu rd, rs1, 1。\n", "relevant": ["beqz"]}, {"name": "sext.w", "content": "sext.w rd, rs1\nx[rd]=sext(x[rs1][31:0])\n有符号字扩展(Sign-extend Word).  伪指令(Pseudoinstruction), RV64I only.\n读入 x[rs1]的低 32 位，有符号扩展，结果写入 x[rd]。实际被扩展为 addiw rd, rs1, 0。\n", "relevant": []}, {"name": "sfence.vma", "content": "sfence.vma rs1, rs2\nFence(Store, AddressTranslation)\n虚拟内存屏障(Fence Virtual Memory). R-type, RV32I and RV64I 特权指令。\n根据后续的虚拟地址翻译对之前的页表存入进行排序。当 rs2=0 时，所有地址空间的翻译都会受到影响；否则，仅对 x[rs2]标识的地址空间的翻译进行排序。当 rs1=0 时，对所选地址空间中的所有虚拟地址的翻译进行排序；否则，仅对其中包含虚拟地址 x[rs1]的页面地址翻译进行排序。\n0001001 rs2 rs1 000 00000 1110011\n", "relevant": []}, {"name": "sgtz", "content": "sgtz rd, rs2\nx[rd]=(x[rs1]>𝑠 0)\n大于0 则置位(Set if Greater Than Zero).  伪指令(Pseudoinstruction), RV32I and RV64I.\n如果 x[rs2]大于 0，向 x[rd]写入 1，否则写入 0。实际被扩展为 slt rd, x0, rs2。\n", "relevant": ["bgtz", "sltz"]}, {"name": "sh", "content": "sh rs2, offset(rs1)\nM[x[rs1]+sext(offset)=x[rs2][15:0]\n存半字(Store Halfword). S-type, RV32I and RV64I.\n将 x[rs2]的低位 2 个字节存入内存地址 x[rs1]+sign-extend(offset)。\noffset[11:5] rs2 rs1 001 offset[4:0] 0100011\n", "relevant": ["lh", "sb", "sd", "sw"]}, {"name": "sw", "content": "sw rs2, offset(rs1)\nM[x[rs1]+sext(offset)=x[rs2][31:0]\n存字(Store Word). S-type, RV32I and RV64I.\n将 x[rs2]的低位 4 个字节存入内存地址 x[rs1]+sign-extend(offset)。\n压缩形式：c.swsp rs2, offset; c.sw rs2, offset(rs1)\noffset[11:5] rs2 rs1 010 offset[4:0] 0100011\n", "relevant": ["fsw", "lw", "sb", "sd", "sh"]}, {"name": "sll", "content": "sll rd, rs1, rs2\nx[rd]=x[rs1]≪x[rs2]\n逻辑左移(Shift Left Logical). R-type, RV32I and RV64I.\n把寄存器 x[rs1]左移 x[rs2]位，空出的位置填入 0，结果写入 x[rd]。x[rs2]的低 5 位（如果是RV64I 则是低 6 位）代表移动位数，其高位则被忽略。\n0000000 rs2 rs1 001 rd 0110011\n", "relevant": ["slli", "sllw", "slt", "srl"]}, {"name": "slli", "content": "slli rd, rs1, shamt\nx[rd]=x[rs1]≪shamt\n立即数逻辑左移(Shift Left Logical Immediate). I-type, RV32I and RV64I.\n把寄存器x[rs1]左移 shamt位，空出的位置填入0，结果写入x[rd]。对于RV32I，仅当shamt[5]=0\n时，指令才是有效的。\n压缩形式：c.slli rd, shamt\n000000 shamt rs1 001 rd 0010011\n", "relevant": ["sll", "slliw", "sllw", "slti", "srli"]}, {"name": "slliw", "content": "slliw rd, rs1, shamt\nx[rd]=sext((x[rs1]≪shamt)[31:0])\n立即数逻辑左移字(Shift Left Logical Word Immediate). I-type, RV64I only.\n把寄存器 x[rs1]左移 shamt 位，空出的位置填入 0，结果截为 32 位，进行有符号扩展后写入x[rd]。仅当 shamt[5]=0 时，指令才是有效的。\n000000 shamt rs1 001 rd 0011011\n", "relevant": ["slli", "sllw", "srliw"]}, {"name": "sllw", "content": "sllw rd, rs1, rs2\nx[rd]=sext((x[rs1]≪x[rs2][4:0])[31:0])\n逻辑左移字(Shift Left Logical Word). R-type, RV64I only.\n把寄存器 x[rs1]的低 32 位左移 x[rs2]位，空出的位置填入 0，结果进行有符号扩展后写入x[rd]。x[rs2]的低 5 位代表移动位数，其高位则被忽略。\n0000000 rs2 rs1 001 rd 0111011\n", "relevant": ["sll", "slli", "slliw", "srlw"]}, {"name": "slt", "content": "slt rd, rs1, rs2\nx[rd]=(x[rs1]<𝑠 x[rs2])\n小于则置位(Set if Less Than). R-type, RV32I and RV64I.\n比较 x[rs1]和 x[rs2]中的数，如果 x[rs1]更小，向 x[rd]写入 1，否则写入 0。\n0000000 rs2 rs1 010 rd 0110011\n", "relevant": ["blt", "sll", "slti", "sltu", "sltz"]}, {"name": "slti", "content": "slti rd, rs1, immediate\nx[rd]=(x[rs1]<𝑠 sext(immediate))\n小于立即数则置位(Set if Less Than Immediate). I-type, RV32I and RV64I.\n比较 x[rs1]和有符号扩展的 immediate，如果 x[rs1]更小，向 x[rd]写入 1，否则写入 0。\nimmediate[11:0] rs1 010 rd 0010011\n", "relevant": ["slli", "slt", "sltiu", "sltu", "sltz"]}, {"name": "sltiu", "content": "sltiu rd, rs1, immediate\nx[rd]=(x[rs1]<𝑢 sext(immediate))\n无符号小于立即数则置位(Set if Less Than Immediate, Unsigned). I-type, RV32I and RV64I.\n比较 x[rs1]和有符号扩展的 immediate，比较时视为无符号数。如果 x[rs1]更小，向 x[rd]写入1，否则写入 0。\nimmediate[11:0] rs1 011 rd 0010011\n", "relevant": ["slti", "sltu"]}, {"name": "sltu", "content": "sltu rd, rs1, rs2\nx[rd]=(x[rs1]<𝑢 x[rs2])\n无符号小于则置位(Set if Less Than, Unsigned). R-type, RV32I and RV64I.\n比较 x[rs1]和 x[rs2]，比较时视为无符号数。如果 x[rs1]更小，向 x[rd]写入 1，否则写入 0。\n0000000 rs2 rs1 011 rd 0110011\n", "relevant": ["bltu", "slt", "slti", "sltiu", "sltz"]}, {"name": "sltz", "content": "sltz rd, rs1\nx[rd]=(x[rs1]<𝑠 0)\n小于0 则置位(Set if Less Than to Zero).  伪指令(Pseudoinstruction), RV32I and RV64I.\n如果 x[rs1]小于 0，向 x[rd]写入 1，否则写入 0。实际扩展为 slt rd, rs1, x0。\n", "relevant": ["bltz", "sgtz", "slt", "slti", "sltu"]}, {"name": "snez", "content": "snez rd, rs2\nx[rd]=x[rs2]≠0)\n不等于0 则置位(Set if Not Equal to Zero).  伪指令(Pseudoinstruction), RV32I and RV64I.\n如果 x[rs1]不等于 0，向 x[rd]写入 1，否则写入 0。实际扩展为 sltu rd, x0, rs2。\n", "relevant": ["bnez"]}, {"name": "sra", "content": "sra rd, rs1, rs2\nx[rd]=(x[rs1]≫𝑠 x[rs2])\n算术右移(Shift Right Arithmetic). R-type, RV32I and RV64I.\n把寄存器 x[rs1]右移 x[rs2]位，空位用 x[rs1]的最高位填充，结果写入 x[rd]。x[rs2]的低 5 位（如果是 RV64I 则是低 6 位）为移动位数，高位则被忽略。\n0100000 rs2 rs1 101 rd 0110011\n", "relevant": ["srai", "sraw", "srl"]}, {"name": "srai", "content": "srai rd, rs1, shamt\nx[rd]=(x[rs1]≫𝑠 shamt)\n立即数算术右移(Shift Right Arithmetic Immediate). I-type, RV32I and RV64I.\n把寄存器 x[rs1]右移 shamt 位，空位用 x[rs1]的最高位填充，结果写入 x[rd]。对于 RV32I，\n仅当 shamt[5]=0 时指令有效。\n压缩形式：c.srai rd, shamt\n010000 shamt rs1 101 rd 0010011\n", "relevant": ["sra", "sraiw", "sraw", "srli"]}, {"name": "sraiw", "content": "sraiw rd, rs1, shamt\nx[rd]=sext(x[rs1][31:0]≫𝑠 shamt)\n立即数算术右移字(Shift Right Arithmetic Word Immediate). I-type, RV64I only.\n把寄存器 x[rs1]的低 32 位右移 shamt 位，空位用 x[rs1][31]填充，结果进行有符号扩展后写入 x[rd]。仅当 shamt[5]=0 时指令有效。\n压缩形式：c.srai rd, shamt\n010000 shamt rs1 101 rd 0011011\n", "relevant": ["srai", "sraw", "srliw"]}, {"name": "sraw", "content": "sraw rd, rs1, rs2\nx[rd]=sext(x[rs1][31:0]≫𝑠 x[rs2][4:0])\n算术右移字(Shift Right Arithmetic Word). R-type, RV64I only.\n把寄存器 x[rs1]的低 32 位右移 x[rs2]位，空位用 x[rs1][31]填充，结果进行有符号扩展后写入 x[rd]。x[rs2]的低 5 位为移动位数，高位则被忽略。\n0100000 rs2 rs1 101 rd 0111011\n", "relevant": ["sra", "srai", "sraiw", "srlw"]}, {"name": "sret", "content": "sret\nExceptionReturn(Supervisor)\n管理员模式例外返回(Supervisor-mode Exception Return). R-type, RV32I and RV64I 特权指令。\n从管理员模式的例外处理程序中返回，设置 pc 为 CSRs[spec]，权限模式为 CSRs[sstatus].SPP，\nCSRs[sstatus].SIE 为 CSRs[sstatus].SPIE，CSRs[sstatus].SPIE 为 1，CSRs[sstatus].spp 为 0。\n0001000 00010 00000 000 00000 1110011\n", "relevant": ["mret", "ret"]}, {"name": "srl", "content": "srl rd, rs1, rs2\nx[rd]=(x[rs1]≫𝑢 x[rs2])\n逻辑右移(Shift Right Logical). R-type, RV32I and RV64I.\n把寄存器 x[rs1]右移 x[rs2]位，空出的位置填入 0，结果写入 x[rd]。x[rs2]的低 5 位（如果是RV64I 则是低 6 位）代表移动位数，其高位则被忽略。\n0000000 rs2 rs1 101 rd 0110011\n", "relevant": ["sll", "sra", "srli", "srlw"]}, {"name": "srli", "content": "srli rd, rs1, shamt\nx[rd]=(x[rs1]≫𝑢 shamt)\n立即数逻辑右移(Shift Right Logical Immediate). I-type, RV32I and RV64I.\n把寄存器x[rs1]右移shamt位，空出的位置填入0，结果写入x[rd]。对于RV32I，仅当shamt[5]=0\n时，指令才是有效的。\n压缩形式：c.srli rd, shamt\n000000 shamt rs1 101 rd 0010011\n", "relevant": ["slli", "srai", "srl", "srliw", "srlw"]}, {"name": "srliw", "content": "srliw rd, rs1, shamt\nx[rd]=sext(x[rs1][31:0]≫𝑢 shamt)\n立即数逻辑右移字(Shift Right Logical Word Immediate). I-type, RV64I only.\n把寄存器 x[rs1]右移 shamt 位，空出的位置填入 0，结果截为 32 位，进行有符号扩展后写入x[rd]。仅当 shamt[5]=0 时，指令才是有效的。\n000000 shamt rs1 101 rd 0011011\n", "relevant": ["slliw", "sraiw", "srli", "srlw"]}, {"name": "srlw", "content": "srlw rd, rs1, rs2\nx[rd]=sext(x[rs1][31:0]≫𝑢 x[rs2][4:0])\n逻辑右移字(Shift Right Logical Word). R-type, RV64I only.\n把寄存器 x[rs1]的低 32 位右移 x[rs2]位，空出的位置填入 0，结果进行有符号扩展后写入x[rd]。x[rs2]的低 5 位代表移动位数，其高位则被忽略。\n0000000 rs2 rs1 101 rd 0111011\n", "relevant": ["sllw", "sraw", "srl", "srli", "srliw"]}, {"name": "sub", "content": "sub rd, rs1, rs2\nx[rd]=x[rs1]−x[rs2]\n减(Substract). R-type, RV32I and RV64I.\nx[rs1]减去 x[rs2]，结果写入 x[rd]。忽略算术溢出。\n压缩形式：c.sub rd, rs2\n0100000 rs2 rs1 000 rd 0110011\n", "relevant": ["sb", "subw"]}, {"name": "subw", "content": "subw rd, rs1, rs2\nx[rd]=sext((x[rs1]−x[rs2])[31:0])\n减去字(Substract Word). R-type, RV64I only.\nx[rs1]减去 x[rs2]，结果截为 32 位，有符号扩展后写入 x[rd]。忽略算术溢出。\n压缩形式：c.subw rd, rs2\n0100000 rs2 rs1 000 rd 0111011\n", "relevant": ["sub"]}, {"name": "tail", "content": "tail symbol\npc=&symbol; clobber x[6]\n尾调用(Tail call).  伪指令(Pseudoinstuction), RV32I and RV64I.\n设置 pc 为 symbol，同时覆写 x[6]。实际扩展为 auipc x6, offsetHi 和 jalr x0, offsetLo(x6)。\n", "relevant": []}, {"name": "wfi", "content": "wfi\nwhile (noInterruptPending) idle\n等待中断(Wait for Interrupt). R-type, RV32I and RV64I 特权指令。\n如果没有待处理的中断，则使处理器处于空闲状态。\n0001000 00101 00000 000 00000 1110011\n", "relevant": []}, {"name": "xor", "content": "xor rd, rs1, rs2\nx[rd]=x[rs1]  ^  x[rs2]\n异或(Exclusive-OR). R-type, RV32I and RV64I.\nx[rs1]和 x[rs2]按位异或，结果写入 x[rd]。\n压缩形式：c.xor rd, rs2\n0000000 rs2 rs1 100 rd 0110011\n", "relevant": ["or"]}]